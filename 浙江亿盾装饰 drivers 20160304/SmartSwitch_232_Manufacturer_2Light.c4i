<devicedata>
    <copyright>Copyright 2004-2008 Control4 Corporation.  All rights reserved.</copyright>
    <creator>SkyNet</creator>
    <manufacturer>SkyNet</manufacturer>
    <name>SmartSwitch-Light</name>
    <model>SmartSwitch Light</model>
    <created>12/31/2015 11:47 AM</created>
    <modified>01/30/2016 4:12 PM</modified>
    <version>11</version>
    <small>devices_sm\c4.gif</small>
    <large>devices_lg\c4.gif</large>
    <control>lua_gen</control>
    <controlmethod>serial</controlmethod>
    <driver>DriverWorks</driver>
    <search_type>SkyNet</search_type>
    <proxies qty="2">
        <proxy proxybindingid="5001" primary="True">light_v2</proxy>
        <proxy proxybindingid="5002">light_v2</proxy>
    </proxies>
    <driverdocumentation>
        <category name="Lighting" description="Lighting">Lighting</category>
    </driverdocumentation>
    <capabilities>
        <advanced_scene_support>True</advanced_scene_support>
        <buttons_are_virtual>True</buttons_are_virtual>
        <has_button_events>True</has_button_events>
        <has_leds>True</has_leds>
        <click_rates>False</click_rates>
        <cold_start>False</cold_start>
        <dimmer>False</dimmer>
        <has_load>True</has_load>
        <hide_proxy_events>False</hide_proxy_events>
        <hold_rates>False</hold_rates>
        <load_group_support>True</load_group_support>
        <max_power>7</max_power>
        <min_max>False</min_max>
        <zero_ten_volt>False</zero_ten_volt>
        <on_off>True</on_off>
        <cold_start>True</cold_start>
    </capabilities>
    <connections>
        <connection>
            <id>1</id>
            <facing>6</facing>
            <connectionname>Serial RS-232</connectionname>
            <type>1</type>
            <consumer>True</consumer>
            <audiosource>False</audiosource>
            <videosource>False</videosource>
            <linelevel>False</linelevel>
            <classes>
                <class>
                    <classname>RS_232</classname>
                </class>
            </classes>
        </connection>
        <connection>
            <id>2</id>
            <facing>1</facing>
            <connectionname>DATA_PROXY</connectionname>
            <type>1</type>
            <consumer>True</consumer>
            <audiosource>False</audiosource>
            <videosource>False</videosource>
            <linelevel>True</linelevel>
            <classes>
                <class>
                    <classname>DATA_PROXY</classname>
                    <autobind>True</autobind>
                </class>
            </classes>
        </connection>
        <connection>
            <id>5001</id>
            <facing>6</facing>
            <connectionname>Light 1</connectionname>
            <type>2</type>
            <consumer>False</consumer>
            <audiosource>False</audiosource>
            <videosource>False</videosource>
            <linelevel>False</linelevel>
            <classes>
                <class>
                    <classname>LIGHT_V2</classname>
                </class>
            </classes>
        </connection>
        <connection>
            <id>5002</id>
            <facing>6</facing>
            <connectionname>Light 2</connectionname>
            <type>2</type>
            <consumer>False</consumer>
            <audiosource>False</audiosource>
            <videosource>False</videosource>
            <linelevel>False</linelevel>
            <classes>
                <class>
                    <classname>LIGHT_V2</classname>
                </class>
                <class>
                    <classname>LIGHT_V2</classname>
                </class>
            </classes>
        </connection>
    </connections>
    <config>
        <identify_text>IlliminationSensor_232_NengHui_NHZD210</identify_text>
        <power_management_method>AlwaysOn</power_management_method>
        <power_command_delay>0</power_command_delay>
        <power_delay>0</power_delay>
        <power_command_needed>False</power_command_needed>
        <serialsettings>9600 8 none 1 none </serialsettings>
        <documentation>
        </documentation>
        <script><![CDATA[--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-- Driver Declarations
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
--[[


  Command Handler Tables


--]]
EX_CMD = {}
PRX_CMD = {}
NOTIFY = {}
DEV_MSG = {}
LUA_ACTION = {}

--[[


Tables of functions


The following tables are function containers that are called within the following functions:  





  OnDriverInit()


    - first calls all functions contained within ON_DRIVER_EARLY_INIT table


    - then calls all functions contained within ON_DRIVER_INIT table


  OnDriverLateInit()


    - calls all functions contained within ON_DRIVER_LATEINIT table


  OnDriverUpdate()


    - calls all functions contained within ON_DRIVER_UPDATE table


  OnDriverDestroyed()


    - calls all functions contained within ON_DRIVER_DESTROYED table


  OnPropertyChanged()


    - calls all functions contained within ON_PROPERTY_CHANGED table


--]]
ON_DRIVER_INIT = {}
ON_DRIVER_EARLY_INIT = {}
ON_DRIVER_LATEINIT = {}
ON_DRIVER_UPDATE = {}
ON_DRIVER_DESTROYED = {}
ON_PROPERTY_CHANGED = {}

-- Constants
DEFAULT_PROXY_BINDINGID = 5001

--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-- Common Driver Code
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
--[[


  OnPropertyChanged


    Function called by Director when a property changes value.


  Parameters


    sProperty


      Name of property that has changed.


  Remarks


    The value of the property that has changed can be found with: Properties[sName]. Note


    that OnPropertyChanged is not called when the Property has been changed by the driver


    calling the UpdateProperty command, only when the Property is changed by the user from


    the Properties Page. This function is called by Director when a property changes value.


--]]
function OnPropertyChanged(sProperty)
  Dbg:Trace("OnPropertyChanged(" .. sProperty .. ") changed to: " .. Properties[sProperty])

  local propertyValue = Properties[sProperty]

  -- Remove any spaces (trim the property)
  local trimmedProperty = string.gsub(sProperty, " ", "")

  -- if function exists then execute (non-stripped)
  if (ON_PROPERTY_CHANGED[sProperty] ~= nil and type(ON_PROPERTY_CHANGED[sProperty]) == "function") then
    ON_PROPERTY_CHANGED[sProperty](propertyValue)
    return
    -- elseif trimmed function exists then execute
  elseif (ON_PROPERTY_CHANGED[trimmedProperty] ~= nil and type(ON_PROPERTY_CHANGED[trimmedProperty]) == "function") then
    ON_PROPERTY_CHANGED[trimmedProperty](propertyValue)
    return
  end

  DriverLib.onPropertyChanged(sProperty, propertyValue)
end

function ON_PROPERTY_CHANGED.DebugMode(propertyValue)
  gDebugTimer:KillTimer()
  Dbg:OutputPrint(propertyValue:find("Print") ~= nil)
  Dbg:OutputC4Log(propertyValue:find("Log") ~= nil)
  if (propertyValue == "Off") then return end
  gDebugTimer:StartTimer()
end

function ON_PROPERTY_CHANGED.DebugLevel(propertyValue)
  Dbg:SetLogLevel(tonumber(string.sub(propertyValue, 1, 1)))
end

---------------------------------------------------------------------
-- ExecuteCommand Code
---------------------------------------------------------------------
--[[


  ExecuteCommand


    Function called by Director when a command is received for this DriverWorks driver.


    This includes commands created in Composer programming.


  Parameters


    sCommand


      Command to be sent


    tParams


      Lua table of parameters for the sent command


--]]
function ExecuteCommand(sCommand, tParams)
  Dbg:Trace("ExecuteCommand(" .. sCommand .. ")")
  Dbg:Info(tParams)

  -- Remove any spaces (trim the command)
  local trimmedCommand = string.gsub(sCommand, " ", "")

  -- if function exists then execute (non-stripped)
  if (EX_CMD[sCommand] ~= nil and type(EX_CMD[sCommand]) == "function") then
    EX_CMD[sCommand](tParams)
    -- elseif trimmed function exists then execute
  elseif (EX_CMD[trimmedCommand] ~= nil and type(EX_CMD[trimmedCommand]) == "function") then
    EX_CMD[trimmedCommand](tParams)
    -- handle the command
  elseif (EX_CMD[sCommand] ~= nil) then
    QueueCommand(EX_CMD[sCommand])
  else
    Dbg:Alert("ExecuteCommand: Unhandled command = " .. sCommand)
  end
end

--[[


  Define any functions of commands (EX_CMD.<command>) received from ExecuteCommand that need to be handled by the driver.


--]]

--[[


  EX_CMD.LUA_ACTION


    Function called for any actions executed by the user from the Actions Tab in Composer.


--]]
function EX_CMD.LUA_ACTION(tParams)
  if tParams ~= nil then
    for cmd,cmdv in pairs(tParams) do
      if cmd == "ACTION" then
        if (LUA_ACTION[cmdv] ~= nil) then
          LUA_ACTION[cmdv]()
        else
          Dbg:Alert("Undefined Action")
          Dbg:Alert("Key: " .. cmd .. " Value: " .. cmdv)
        end
      else
        Dbg:Alert("Undefined Command")
        Dbg:Alert("Key: " .. cmd .. " Value: " .. cmdv)
      end
    end
  end
end

--[[


  LUA_ACTION.DisplayGlobals


    Implementation of Action "Display Globals". Executed when selecting the "Display Globals" action within Composer.


    Provided as an example for actions.


--]]
function LUA_ACTION.DisplayGlobals()
  print ("Global Variables")
  print ("----------------------------")

  for k,v in pairs(_G) do -- globals`
    if not (type(v) == "function") then
      --print(k .. ":  " .. tostring(v))
      if (string.find(k, "^g%L")  == 1) then
        print(k .. ":  " .. tostring(v))
        if (type(v) == "table") then
          PrintTable(v, "   ")
        end
      end
  end
  end

  print ("")
end

function PrintTable(tValue, sIndent)
  sIndent = sIndent or "   "
  for k,v in pairs(tValue) do
    print(sIndent .. tostring(k) .. ":  " .. tostring(v))
    if (type(v) == "table") then
      PrintTable(v, sIndent .. "   ")
    end
  end
end

---------------------------------------------------------------------
-- ReceivedFromProxy Code
---------------------------------------------------------------------
--[[


  ReceivedFromProxy(idBinding, sCommand, tParams)


    Function called by Director when a proxy bound to the specified binding sends a


    BindMessage to the DriverWorks driver.





  Parameters


    idBinding


      Binding ID of the proxy that sent a BindMessage to the DriverWorks driver.


    sCommand


      Command that was sent


    tParams


      Lua table of received command parameters


--]]
function ReceivedFromProxy(idBinding, sCommand, tParams)
  if (sCommand ~= nil) then
    if(tParams == nil)    -- initial table variable if nil
    then tParams = {}
    end
    Dbg:Trace("ReceivedFromProxy(): " .. sCommand .. " on binding " .. idBinding .. "; Call Function " .. sCommand .. "()")
    Dbg:Info(tParams)

    if (PRX_CMD[sCommand]) ~= nil then
      PRX_CMD[sCommand](idBinding, tParams)
    else
      Dbg:Alert("ReceivedFromProxy: Unhandled command = " .. sCommand)
    end
  end
end

---------------------------------------------------------------------
-- Notification Code
---------------------------------------------------------------------
-- notify with parameters
function SendNotify(notifyText, Parms, bindingID)
  C4:SendToProxy(bindingID, notifyText, Parms, "NOTIFY")
end

-- A notify with no parameters
function SendSimpleNotify(notifyText, ...)
  bindingID = select(1, ...) or DEFAULT_PROXY_BINDINGID
  C4:SendToProxy(bindingID, notifyText, {}, "NOTIFY")
end

---------------------------------------------------------------------
-- Initialization/Destructor Code
---------------------------------------------------------------------
--[[


  OnDriverInit


    Invoked by director when a driver is loaded. This API is provided for the driver developer to contain all of the driver


    objects that will require initialization.


--]]
function OnDriverInit()
  C4:ErrorLog("INIT_CODE: OnDriverInit()")
  -- Call all ON_DRIVER_EARLY_INIT functions.
  for k,v in pairs(ON_DRIVER_EARLY_INIT) do
    if (ON_DRIVER_EARLY_INIT[k] ~= nil and type(ON_DRIVER_EARLY_INIT[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_EARLY_INIT." .. k .. "()")
      ON_DRIVER_EARLY_INIT[k]()
    end
  end

  -- Call all ON_DRIVER_INIT functions
  for k,v in pairs(ON_DRIVER_INIT) do
    if (ON_DRIVER_INIT[k] ~= nil and type(ON_DRIVER_INIT[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_INIT." .. k .. "()")
      ON_DRIVER_INIT[k]()
    end
  end

  -- Fire OnPropertyChanged to set the initial Headers and other Property global sets, they'll change if Property is changed.
  for k,v in pairs(Properties) do
    OnPropertyChanged(k)
  end
end

--[[


  OnDriverUpdate


    Invoked by director when an update to a driver is requested. This request can occur either by adding a new version of a driver


    through the driver search list or right clicking on the driver and selecting "Update Driver" from within ComposerPro.


    Its purpose is to initialize all components of the driver that are reset during a driver update.


--]]
function OnDriverUpdate()
  C4:ErrorLog("INIT_CODE: OnDriverUpdate()")

  -- Call all ON_DRIVER_UPDATE functions
  for k,v in pairs(ON_DRIVER_UPDATE) do
    if (ON_DRIVER_UPDATE[k] ~= nil and type(ON_DRIVER_UPDATE[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_UPDATE." .. k .. "()")
      ON_DRIVER_UPDATE[k]()
    end
  end
end

--[[


  OnDriverLateInit


    Invoked by director after all drivers in the project have been loaded. This API is provided


    for the driver developer to contain all of the driver objects that will require initialization


    after all drivers in the project have been loaded.


--]]
function OnDriverLateInit()
  C4:ErrorLog("INIT_CODE: OnDriverLateInit()")

  -- Call all ON_DRIVER_LATEINIT functions
  for k,v in pairs(ON_DRIVER_LATEINIT) do
    if (ON_DRIVER_LATEINIT[k] ~= nil and type(ON_DRIVER_LATEINIT[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_LATEINIT." .. k .. "()")
      ON_DRIVER_LATEINIT[k]()
    end
  end
end


--[[


  OnDriverDestroyed


    Function called by Director when a driver is removed. Release things this driver has allocated such as timers.


--]]
function OnDriverDestroyed()
  C4:ErrorLog("INIT_CODE: OnDriverDestroyed()")
  -- Call all ON_DRIVER_DESTROYED functions
  for k,v in pairs(ON_DRIVER_DESTROYED) do
    if (ON_DRIVER_DESTROYED[k] ~= nil and type(ON_DRIVER_DESTROYED[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_DESTROYED." .. k .. "()")
      ON_DRIVER_DESTROYED[k]()
    end
  end
end

--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-- Debug Logging Code
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Log = {}

-- Create a Table with Logging functions
function Log:Create()

  -- table for logging functions
  local lt = {}

  lt._logLevel = 0
  lt._outputPrint = false
  lt._outputC4Log = false
  lt._logName =  "Set Log Name to display"

  function lt:SetLogLevel(level)
    self._logLevel = level
  end

  function lt:OutputPrint(value)
    self._outputPrint = value
  end

  function lt:OutputC4Log(value)
    self._outputC4Log = value
  end

  function lt:SetLogName(name)
    self._logName = name
  end

  function lt:Enabled()
    return (self._outputPrint or self._outputC4Log)
  end

  function lt:PrintTable(tValue, sIndent)
    if (type(tValue) == "table") then
      if (self._outputPrint) then
        for k,v in pairs(tValue) do
          print(sIndent .. tostring(k) .. ":  " .. tostring(v))
          if (type(v) == "table") then
            self:PrintTable(v, sIndent .. "   ")
          end
        end
      end

      if (self._outputC4Log) then
        for k,v in pairs(tValue) do
          C4:ErrorLog(self._logName .. ": " .. sIndent .. tostring(k) .. ":  " .. tostring(v))
          if (type(v) == "table") then
            self:PrintTable(v, sIndent .. "   ")
          end
        end
      end

    else
      if (self._outputPrint) then
        print (sIndent .. tValue)
      end

      if (self._outputC4Log) then
        C4:ErrorLog(self._logName .. ": " .. sIndent .. tValue)
      end
    end
  end

  function lt:Print(logLevel, sLogText)
    if (self._logLevel >= logLevel) then
      if (type(sLogText) == "table") then
        self:PrintTable(sLogText, "   ")
        return
      end

      if (self._outputPrint) then
        print (sLogText)
      end

      if (self._outputC4Log) then
        C4:ErrorLog(self._logName .. ": " .. sLogText)
      end
    end
  end

  function lt:Alert(strDebugText)
    self:Print(0, strDebugText)
  end

  function lt:Error(strDebugText)
    self:Print(1, strDebugText)
  end

  function lt:Warn(strDebugText)
    self:Print(2, strDebugText)
  end

  function lt:Info(strDebugText)
    self:Print(3, strDebugText)
  end

  function lt:Trace(strDebugText)
    self:Print(4, strDebugText)
  end

  function lt:Debug(strDebugText)
    self:Print(5, strDebugText)
  end

  return lt
end

function ON_DRIVER_EARLY_INIT.LogLib()
  -- Create and initialize debug logging
  Dbg = Log.Create()
  Dbg:SetLogName("SmartSwitch")
end

function ON_DRIVER_INIT.LogLib()
  -- Create Debug Timer
  gDebugTimer = Timer:Create("Debug", 45, "MINUTES", OnDebugTimerExpired)
end

--[[


  OnDebugTimerExpired


    Debug timer callback function


--]]
function OnDebugTimerExpired()
  Dbg:Warn("Turning Debug Mode Off (timer expired)")
  gDebugTimer:KillTimer()
  C4:UpdateProperty("Debug Mode", "Off")
  OnPropertyChanged("Debug Mode")
end

---------------------------------------------------------------------
-- Timer Code
---------------------------------------------------------------------
Timer = {}

-- Create a Table with Timer functions
function Timer:Create(name, interval, units, Callback, repeating, Info)
  -- timers table
  local tt = {}

  tt._name = name
  tt._timerID = TimerLibGetNextTimerID()
  tt._interval = interval
  tt._units = units
  tt._repeating = repeating or false
  tt._Callback = Callback
  tt._info = Info or ""
  tt._id = 0

  function tt:StartTimer(...)
    self:KillTimer()

    -- optional parameters (interval, units, repeating)
    if ... then
      local interval = select(1, ...)
      local units = select(2, ...)
      local repeating = select(3, ...)

      self._interval = interval or self._interval
      self._units = units or self._units
      self._repeating = repeating or self._repeating
    end

    if (self._interval > 0) then
      Dbg:Trace("Starting Timer: " .. self._name)
      self._id = C4:AddTimer(self._interval, self._units, self._repeating)
    end
  end

  function tt:KillTimer()
    if (self._id) then
      self._id = C4:KillTimer(self._id)
    end
  end

  function tt:TimerStarted()
    return (self._id ~= 0)
  end

  function tt:TimerStopped()
    return not self:TimerStarted()
  end

  gTimerLibTimers[tt._timerID] = tt
  Dbg:Trace("Created timer " .. tt._name)

  return tt
end

function TimerLibGetNextTimerID()
  gTimerLibTimerCurID = gTimerLibTimerCurID + 1
  return gTimerLibTimerCurID
end

function ON_DRIVER_EARLY_INIT.TimerLib()
  gTimerLibTimers = {}
  gTimerLibTimerCurID = 0
end

function ON_DRIVER_DESTROYED.TimerLib()
  -- Kill open timers
  for k,v in pairs(gTimerLibTimers) do
    v:KillTimer()
  end
end

--[[


  OnTimerExpired


    Function called by Director when the specified Control4 timer expires.


  Parameters


    idTimer


      Timer ID of expired timer.


--]]
function OnTimerExpired(idTimer)
  for k,v in pairs(gTimerLibTimers) do
    if (idTimer == v._id) then
      if (v._Callback) then
        v._Callback(v._info)
      end
    end
  end
end


------------------------------------------------------------------------
-- Below are mine driver common scripts
-- Will do below
-- 1. First of all, declare several important status variable
-- 2. Add properties change handler
-- 3. Add "show status" command handler
-- 4. Add code for using or not using serial agent
-- 5. Add error message display method

local COMMON_CONSTANT = {
  COMM_WITH_SERIAL_AGENT = "comm-by-serial-agent",
  COMM_WITH_SERIAL_PORT = "comm-by-serial-port"
}
--- Serial communication address for current device
local deviceAddress
--- communication mode. 1- use serial-agent driver, 2- directly use serial port
local communicationMode
local serialAgentDevId = 1
local oldSerialAgentDevId = 1
--- print binary serial data package or not
local isDumpSerialData = false
--- buffer for framed receving-command strings
local recvFrameDatas = {}
--- framing timer
local framingTimer
local frameingTimerCnt = 0

--- action commond
function LUA_ACTION.ShowStatus()
  print("Device address  is " .. deviceAddress)
  print("Communication mode is " .. communicationMode)
  print("Serial Agent device ID is " .. serialAgentDevId)
  DriverLib.printProperties()
end

--- Common property on-change handlers
ON_PROPERTY_CHANGED["Use Serial Agent"] = function(propValue)
  if (propValue == "Yes") then
    communicationMode = COMMON_CONSTANT.COMM_WITH_SERIAL_AGENT
  else
    communicationMode = COMMON_CONSTANT.COMM_WITH_SERIAL_PORT
  end
  Dbg:Info("Set communication mode to "..(isDumpSerialData and "Yes" or "No"))
  RebindSerialAgent()
end

ON_PROPERTY_CHANGED["Address"] = function(propValue)
  deviceAddress = tonumber(propValue)
  Dbg:Info("Set device self serial communication address to "..deviceAddress)
end

ON_PROPERTY_CHANGED["Dump Serial Data"] = function(propValue)
  isDumpSerialData = propValue == "Yes"
  Dbg:Info("Set dump serial data to "..(isDumpSerialData and "Yes" or "No"))
end

ON_PROPERTY_CHANGED["Serial Agent Device ID"] = function(propValue)
  serialAgentDevId = tonumber(propValue)
  Dbg:Info("Serial agent used is "..serialAgentDevId)
  RebindSerialAgent()
end

--- Common functions for comminication
--- register with serial-agent variables
function RebindSerialAgent()
  C4:UnregisterVariableListener(oldSerialAgentDevId, 1002)
  Dbg:Info("Release old binded serial agent "..oldSerialAgentDevId)
  oldSerialAgentDevId = serialAgentDevId
  if (serialAgentDevId > 0 and communicationMode == COMMON_CONSTANT.COMM_WITH_SERIAL_AGENT) then
    C4:RegisterVariableListener(serialAgentDevId, 1002)
    Dbg:Info("Bind me to serial agent "..serialAgentDevId)
  end
end
--- hanlde serial-agent notification
function OnWatchedVariableChanged(idDevice, idVariable, strValue)
  Dbg:Debug({idDevice=idDevice, idVariable=idVariable, strValue=strValue})

  if (idDevice == serialAgentDevId and idVariable==1002 and communicationMode == COMMON_CONSTANT.COMM_WITH_SERIAL_AGENT) then
    OnRecieveFromSerialAgent(strValue)
  end
end

--- forward data received from serial-agent
function OnRecieveFromSerialAgent(strDataSeq)
  if (not strDataSeq) then
    return
  end
  local numDataSeq = tonumber(strDataSeq)
  if (not numDataSeq or numDataSeq < 1002) then
    return
  end
  local recvStr = C4:GetDeviceVariable(serialAgentDevId, numDataSeq)
  local strData = C4:Base64Decode(recvStr)
  if (isDumpSerialData) then
    print("\n\n\nReceive below data from serial agent:")
    hexdump(strData)
  end
  OnSerialDataReceived(strData)
end
--- handle data received from serial port
function ReceivedFromSerial(idBinding, strData)
  if strData == nil then
    return
  end
  if (communicationMode ~= COMMON_CONSTANT.COMM_WITH_SERIAL_PORT) then
    return
  end

  table.insert(recvStrDatas, strData)
  if (#strData < pieceSize) then
    frameingTimerCnt = 0
    handleFrameData()
  else
    frameingTimerCnt = 3
  end
end

function cutdownTimer()
  if (frameingTimerCnt == 0) then
    return
  end
  frameingTimerCnt = frameingTimerCnt - 1
  if (frameingTimerCnt <= 0) then
    handleFrameData()
  end
end

-- when found a whole piece frame data, send out the signal
function handleFrameData()
  local str = "";
  local len = #recvStrDatas
  if (len < 1) then
    return
  end

  for k=1,len do
    str =  str .. recvStrDatas[k]
  end
  recvStrDatas = {}

  if (isDumpSerialData) then
    print("\n\n\nReceive below data from serial port")
    hexdump(strData)
  end
  OnSerialDataReceived(strData)
end


function OnSerialDataReceived(strData)
  if (type(strData) ~= "string") then return end
  if (#strData < 5) then return end
  if (string.byte(strData,1,1) ~= 0xFF) then return end
  if (string.byte(strData,2,2) ~= deviceAddress) then return end
  handleSerialInput(1, strData)
end

local outputVar_mode;
local outoutVar_relay1;
local outputVar_relay2
local outputVars = {
  ["WorkMode"] = "Light",
  ["Relay1"] = "Open",
  ["Relay2"] = "Open",
  ["Dimmer"] = 0,
}
function ON_DRIVER_INIT.driverCommonInit()
  print("Do driver common init()")
  framingTimer = Timer:Create("framing timer", 10, "MILLISECONDS", OnTestTimer, true, "framing timer")
  framingTimer:StartTimer()
  RebindSerialAgent()
  local keySet = {}
  for k,v in pairs(outputVars) do
    table.insert(keySet, k)
  end
  table.sort(keySet)
  for k,v in pairs(keySet) do
	print("Add Variable " .. v .. " as " .. outputVars[v])
    C4:AddVariable(v, outputVars[v], (v=="Dimmer") and "NUMBER" or "STRING")
  end
end
----------------------------------------------------------------------------
function updateVariable(name, value)
  local oldValue = outputVars[name]
  if (oldValue == nil) then 
    print("Don't know about variable " .. name)
    return
  end
  if oldValue == value then return end
  outputVars[name] = value
  Dbg:Info("Update variable " .. name .. " to " .. value)
  C4:SetVariable(name, value)
end

function SendCommand(strData)

  if communicationMode == COMMON_CONSTANT.COMM_WITH_SERIAL_PORT then
    C4:SendToSerial(1, strData)
    if (isDumpSerialData) then
      print("\n\n\nSend below data to serial port")
      hexdump(strData)
    end
    return
  end

  local base64Str = C4:Base64Encode(strData)
  C4:SendToDevice(serialAgentDevId, "SendCommand", {strData=base64Str})
  if (isDumpSerialData) then
    print("Send below data to serial agent")
    hexdump(strData)
  end
end


----------------------------------------------------------------------------
DriverLib = {configData=nil}

function DriverLib.tableToString(tbl, prefix)
  local rstStr = "{"
  prefix = prefix or ""
  local keyTbl = {}
  for k,v in pairs(tbl) do
    table.insert(keyTbl,k)
  end
  table.sort(keyTbl)
  
  for i,k in pairs(keyTbl) do
    local v = tbl[k]
    if (type(v) == "table") then
      rstStr = rstStr .. prefix .. k .. DriverLib.tableToString(v, prefix .. "    ")
    else
      if (rstStr ~= "{") then
        rstStr = rstStr .. ", "
      end
      rstStr = rstStr .. prefix .. k .. "=" 
      if (type(v) == "string") then
        rstStr = rstStr .. "\"" .. tostring(v or "nil") .. "\""
      else
        rstStr = rstStr .. tostring(v or "nil")
      end
    end
  end
  return rstStr .. "}"
end
function DriverLib.sleep(timeSec)
  socket.select(nil, nil, timeSec)
end

function DriverLib.setConfig(data)
  DriverLib.configData = data
end

function DriverLib.postMsg(msg)
  C4:UpdateProperty("Error Message", msg)
  Dbg:Warn(msg)
end
function DriverLib.log(msg)
  Dbg:Info(msg)
end

function DriverLib.setList(info, propertyValue)
  if (not info.propertyList) then
    DriverLib.postMsg("[Error]: " .. info.displayName .. " has not defined List property")
    return
  end
  if (not info.propertyList[propertyValue]) then
    DriverLib.postMsg("[Error]: " .. info.displayName .. " has no value defined for " .. propertyValue .. " in the List")
    return
  end
  info.value = info.propertyList[propertyValue]
  DriverLib.log("[Log  ]: " .. info.displayName .. " set to " .. info.value)
end

function DriverLib.setNumber(info, propertyValue)
  info.value = tonumber(propertyValue)
end

function DriverLib.setString(info, propertyValue)
  info.value = tostring(propertyValue)
end

function DriverLib.readOnly(info, propertyValue)
  DriverLib.postMsg("[Error]: " .. info.displayName .. " is readonly")
end

function DriverLib.fireEvent(info, eventName)
  DriverLib.log("[EVENT OCCURRED]: " .. eventName)
  C4:FireEvent(eventName)
end

function DriverLib.updateProperty(info, value)
  DriverLib.log("Set " .. info.propertyName .. " to " .. tostring(value or "nil"))
  C4:UpdateProperty(info.propertyName, value)
  if (info.propertyList == nil) then
    info.value = value
    return
  end
  DriverLib.setList(info, value)
end

function DriverLib.onPropertyChanged(propName, propValue)
  for k,info in pairs(config.iodef) do
    if info.propertyName == propName then
      info.propertyHandler(info, propValue)
    end
  end
end

function DriverLib.printProperties()
  for k,info in pairs(DriverLib.configData.iodef) do
    print("The [" .. info.displayName .. "] is " .. tostring(info.value or "nil"))
  end
end

function DriverLib.get(name)
  return DriverLib.configData.iodef[name].value
end
----------------------------------------------------------------------------
-- Above codes are driver common scripts
-- Below is mine
----------------------------------------------------------------------------

local MODE_LIGHT = 0
local MODE_BLIND = 1
local MODE_SCENE = 2
local MODE_DIMMER = 3
local modeName = {
  [MODE_LIGHT] = "Light",
  [MODE_BLIND]  = "Blind",
  [MODE_SCENE] = "Scene",
  [MODE_DIMMER] = "Dimmer"
}

config = {}
config.iodef = {
  workMode = {
    displayName = "work mode",
    propertyName = "Device Work Mode",
    propertyHandler = DriverLib.setList,
    propertyList = {
      ["Light"] = MODE_LIGHT,
      ["Blind"] = MODE_BLIND,
      ["Scene"] = MODE_SCENE,
      ["Dimmer"] = MODE_DIMMER
    },
    value = 0,
  },
  light1 = {
    displayName = "Light 1",
    propertyName = "Light 1 State",
    propertyHandler = DriverLib.readOnly,
    value="OFF"
  },
  light2 = {
    displayName = "Light 2",
    propertyName = "Light 2 State",
    propertyHandler = DriverLib.setNumber,
    value="OFF"
  },
  blindUpRelay = {
    displayName = "blind up relay ID",
    propertyName = "Blind Up Relay",
    propertyHandler = DriverLib.setNumber,
    value = 1,
  },
  blind = {
    displayName = "blind",
    propertyName = "Blind",
    propertyHandler = DriverLib.readOnly,
    value="STOP",
  },
  dimmerLevel = {
    displayName = "dimmer level",
    propertyName = "Dimmer Level",
    propertyHandler = function(info, value)
      local level = tonumber(value)
      DriverLib.postMsg(setDimmerLevel(level))
    end,
    value=0
  }
}

DriverLib.setConfig(config)
------------------------------------------------------------------------
-- below are driver scripts for smart switch
--
function EX_CMD.SetRelay(tParams)
  Dbg:Debug("Execute command SetRelay(" .. DriverLib.tableToString(tParams) ..")")
  if tParams.group == nil then
    Dbg:Error("Command SetRelay without group")
    return
  end
  if tParams.state == nil then
    Dbg:Error("Command SetRelay without state")
    return
  end
  if (not inTable({"Open", "Close"}, tParams.state)) then
    Dbg:Error("Command SetRelay only accept Open or Close")
    return
  end
  local rst = controlDevice(tonumber(tParams.group), tParams.state == "Open" and 0 or 1, {MODE_LIGHT,MODE_BLIND})
  Dbg:Error("Command SetRelay " .. rst)
end

function EX_CMD.PerformScene(tParams)
  Dbg:Debug("Execute command PerformScene(" .. DriverLib.tableToString(tParams) ..")")
  if tParams.group == nil then
    Dbg:Error("Command PerformScene without group")
    return
  end
  local rst = performScene(tonumber(tParams.group))
  Dbg:Error("Command PerformScene " .. rst)
end 

function EX_CMD.SetDimmerLevel(tParams)
  Dbg:Debug("Execute SetDimmerLevel (" .. DriverLib.tableToString(tParams) ..")")
  if tParams.level == nil then
    Dbg:Error("Command SetDimmerLevel without level")
    return
  end
  local rst = setDimmerLevel(tonumber(tParams.level))
  Dbg:Error("Command SetDimmerLevel " .. rst)
end 

local usedRelay = 0;
constants = {

    ERROR_NO_ERROR = "SUCCESS",
    ERROR_NO_RESPONSE = "NO RESPONSE",
    ERROR_CRC_ERROR = "CRC ERROR",
    ERROR_WRONG_FUNCTION_CODE = "WRONG FUNCTION CODE",
    ERROR_WRONG_RESPONSE_CODE = "WRONG RESPONSE CODE",
    ERROR_WRONG_GROUP_NUM = "WRONG GROUP NUMBER",
    ERROR_WRONG_WORK_MODE = "WRONG WORK MODE",
    ERROR_WRONG_LEVLE_NUM = "WRONG DIMMER LEVEL",
    ERROR_HALF_RESPONSE = "HALF_BACKED RESPONSE",
    ERROR_SET_FAILED = "FAILED TO SET VALUE",
    ERROR_NOT_MINE = "IGNORE RESPONSE NOT MINE"
}

function lrc(strData, len)
  len = len or #strData
  local lrc = 0
  for i=2,len do
    lrc = lrc + string.byte(strData,i,i)
  end
  return string.char(bit.band(lrc, 0xFF))
end

function verifyLrc(strData, len)
  len = len or #strData
  local calcLrc = lrc(strData, len-1)
  return calcLrc == string.sub(strData,len,len)
end

--- means of verifyRules is:
-- if request cmd=0xAA, response code should be 0xAA, at least 7 bytes
-- if request cmd=0xA0, response code should be 0xA0, at least 7 bytes
-- if request cmd=0x00, which means this is active-report msg, code should be 0xAA, at least 7 bytes
local verifyRules = {
  [0xAA] = { [0xAA] = true, minLength = 7 },
  [0xA0] = { [0xAA] = true, minLength = 7 },
  [0x00] = { [0xAA] = true, minLength = 7 },
}

function verifyResponse(reqFuncCode, strData)
  local result = {errorState=constants.ERROR_NO_ERROR}

  if (string.byte(strData,1,1) ~= 0xFF) then
    result.errorState = constants.ERROR_NOT_MINE
    return result
  end
  -- verify CRC
  if (not verifyLrc(strData,#strData)) then
    result.errorState = constants.ERROR_CRC_ERROR
    return result
  end

  -- is this my supported function code?
  local verifyRule = verifyRules[reqFuncCode]
  if (not verifyRule) then
    result.errorState = constants.ERROR_WRONG_FUNCTION_CODE
    return result
  end

  local respFunCode = string.byte(strData,5,5)
  if (not verifyRule[respFunCode]) then
    result.errorState = constants.ERROR_WRONG_RESPONSE_CODE
    result.code = respFunCode
    return result
  end

  if (#strData < verifyRule.minLength) then
    result.errorState = constants.ERROR_HALF_RESPONSE
    return result
  end

  if (string.byte(strData,2,2) ~= deviceAddress) then
    result.errorState = constants.ERROR_NOT_MINE
  end
  return result
end


----------------------------------------------------------
function parseInputData(strData)
  local tgtAddress = string.byte(strData,2,2)
  local group = string.byte(strData,3,3)
  local mode = string.byte(strData,4,4)
  local msgType = string.byte(strData,5,5)
  local value = string.byte(strData,6,6)
  local result = {
    errorState=constants.ERROR_NO_ERROR,
    mode = mode,
    group=group,
    value=value
  }
  return result
end

function commonResponseHandler(idBinding, strData, funCode, tParams)
  local result = verifyResponse(funCode, strData)
  if (result.errorState ~= constants.ERROR_NO_ERROR) then
    return result
  end

  return parseInputData(strData)
end

----------------------------------
-- tParams format: 1-deviceID, 2-group, 3-value
local cmdMaker = {
  commandCode = nil,
  commandParams = nil,
  cmdReadState = {
    functionCode = 0xAA,
    command = function(tParams, funCode)
      return string.format("FF %02X %02X 00 AA 00", tParams[1], tParams[2])
    end,
    responseHandler = commonResponseHandler

  },
  cmdSetState = {
    functionCode = 0xA0,
    command = function(tParams, funCode)
      return string.format("FF %02X %02X %02X A0 %02X", tParams[1], tParams[2], DriverLib.get("workMode"), tParams[3])
    end,
    responseHandler = commonResponseHandler
  },
  cmdActiveResport = {
    functionCode = 0x00,
    command = function(tParams)
      -- this will never be used
      print("You should never use me.")
    end,
    responseHandler = commonResponseHandler
  }
}

function sendOneCommand(code, tParams)
  local cmdInfo = cmdMaker[code]
  local cmdStr = cmdInfo.command(tParams, cmdInfo.functionCode)
  cmdMaker.commandCode = code
  cmdMaker.commandParams = tParams
  local cmdBytes = tohex(cmdStr)
  cmdBytes = cmdBytes .. lrc(cmdBytes)
  SendCommand(cmdBytes)
end

-- TODO :3
function setProperty(name, value)
  local info = config.iodef[name]
  DriverLib.updateProperty(info, value)
end

--TODO: add setVariables
local dataHandler = {
  [MODE_LIGHT] = function(rstData)
    updateVariable("WorkMode", "Light")
    setProperty("workMode", modeName[MODE_LIGHT])
    local groupNo = tonumber(rstData.group)
    if rstData.value == 0 then
      setProperty("light"..rstData.group, "Close")
      DriverLib.fireEvent(nil, "Light " .. rstData.group .. " Close")
      updateVariable("Relay".. rstData.group, "Open")
	 C4:SendToProxy(5000+groupNo,"LIGHT_LEVEL",0)
    else
      setProperty("light"..rstData.group, "Open")
      DriverLib.fireEvent(nil, "Light " .. rstData.group .. " Open")
      updateVariable("Relay".. rstData.group, "Close")
	 C4:SendToProxy(5000+groupNo,"LIGHT_LEVEL",100)
    end
    setProperty("blind", "")
    setProperty("dimmerLevel", 0)
  end,
  [MODE_BLIND] = function(rstData)
    setProperty("workMode", modeName[MODE_BLIND])
    local state = "STOP"
    updateVariable("WorkMode", "Blind")
    if rstData.value == 0 then
      setProperty("blind", "Stop")
      DriverLib.fireEvent(nil, "Blind Stop")
      updateVariable("Relay1", "Open")
      updateVariable("Relay2", "Open")
    elseif rstData.group == DriverLib.get("blindUpRelay") then
      setProperty("blind", "Up")
      DriverLib.fireEvent(nil, "Blind Up")
      updateVariable("Relay"..rstData.group, "Close")
    else
      setProperty("blind", "Down")
      DriverLib.fireEvent(nil, "Blind Down")
      updateVariable("Relay"..rstData.group, "Close")
    end
    setProperty("light1", "")
    setProperty("light2", "")
    setProperty("dimmerLevel", 0)
  end,
  [MODE_SCENE] = function(rstData)
    updateVariable("WorkMode", "Scene")
    updateVariable("Relay"..rstData.group, (rstData.value == 0) and "Open" or "Close")
    setProperty("workMode", modeName[MODE_SCENE])
    setProperty("light1", "")
    setProperty("light2", "")
    setProperty("blind", "")
    setProperty("dimmerLevel", 0)
  end,
  [MODE_DIMMER] = function(rstData)
    updateVariable("WorkMode", "Dimmer")
    updateVariable("Dimmer", rstData.value)
    setProperty("workMode", modeName[MODE_DIMMER])
    setProperty("light1", "")
    setProperty("light2", "")
    setProperty("blind", "")
    setProperty("dimmerLevel", rstData.value)
    DriverLib.fireEvent(nil, "Dimmer Level Changed")
  end,
}

function handleSerialInput(idBinding, strData) --TODO
  if (not cmdMaker.commandCode) then
    print("\n\nMaybe this is active-report message")
    cmdMaker.commandCode = "cmdActiveResport"
  end
  local cmdInfo = cmdMaker[cmdMaker.commandCode]
  local params = cmdMaker.commandParams
  --  print("response from " .. cmdMaker.commandCode)
  cmdMaker.commandCode = nil
  cmdMaker.commandParams = nil
  --  hexdump (strData)
  local result = cmdInfo.responseHandler(idBinding, strData, cmdInfo.functionCode, params)

  if (result.errorState ~= constants.ERROR_NO_ERROR) then
    DriverLib.postMsg("has error ".. result.errorState)
    return
  end

  if (type(dataHandler[result.mode]) ~= "function") then
    DriverLib.postMsg("has error: cannot found data handler for " .. result.mode)
    return
  end

  dataHandler[result.mode](result)
end

function initSmartSwitch()
  local value = Properties[deviceWorkModePropertyName]
  if (not WORK_MODE[value]) then
    print("Work mode not correct")
    -- this should be never happed, because we will use a LIST property in the driver
    -- this is only occurs when simulating
  end
  deviceWorkMode = value
  print("[Init] device work mode is " .. deviceWorkMode)

  deviceAddress = tonumber(Properties[deviceAddressPropertyName])
  print("[Init] device 485 address is " .. string.format("0x%02X", deviceAddress))

  blindUpGroup = tonumber(Properties[blindUpGroupPropertyName])
  print("[Init] device use relay " .. blindUpGroup .. " to make blind up")
end
--------------------------------------------------------------------------
function LUA_ACTION.OpenGroup1()
  C4:SendToProxy(5001,"LIGHT_LEVEL",100)
  DriverLib.postMsg(controlDevice(1, 1, {MODE_LIGHT,MODE_BLIND}))
end
function LUA_ACTION.CloseGroup1()
  C4:SendToProxy(5001,"LIGHT_LEVEL",0)
  DriverLib.postMsg(controlDevice(1, 0, {MODE_LIGHT,MODE_BLIND}))
end
function LUA_ACTION.OpenGroup2()
  C4:SendToProxy(5002,"LIGHT_LEVEL",100)
  DriverLib.postMsg(controlDevice(2, 1, {MODE_LIGHT,MODE_BLIND}))
end
function LUA_ACTION.CloseGroup2()
  C4:SendToProxy(5002,"LIGHT_LEVEL",0)
  DriverLib.postMsg(controlDevice(2, 0, {MODE_LIGHT,MODE_BLIND}))
end
function LUA_ACTION.CheckState()
  DriverLib.postMsg(readFromDevice())
end
function LUA_ACTION.PerformScene1()
  DriverLib.postMsg(performScene(1))
end
function LUA_ACTION.PerformScene2()
  DriverLib.postMsg(performScene(2))
end
function LUA_ACTION.BlindUp()
  DriverLib.postMsg(controlBlind("up"))
end
function LUA_ACTION.BlindDown()
  DriverLib.postMsg(controlBlind("down"))
end
function LUA_ACTION.BlindStop()
  DriverLib.postMsg(controlBlind("stop"))
end
--------------------------------------------------------------------------
-- Below are callbacks intergated with composer
--function OnDriverInit()
--initSmartSwitch()
--end
--------------------------------------------------

function blindToggle()
  usedRelay = 3-usedRelay
  return executeCmd("Blind", usedRelay, 1)
end

function dimmerSetLevel(level)
  return executeCmd("Dimmer", 0, level)
end

function getState(group)
  if group > 2 or group < 1 then
    return {errorState = constants.ERROR_WRONG_GROUP_NUM}
  end
  sendOneCommand("cmdReadState", {deviceAddress, group})
  return {errorState = constants.ERROR_NO_ERROR}
end

function inTable(tbl, value)
  for k,v in pairs(tbl) do
    if v == value then
      return true
    end
  end
  return false
end

function controlDevice(group, value, validMode)
  local curMode = DriverLib.get("workMode")
  if (not inTable(validMode, curMode)) then
    return constants.ERROR_WRONG_WORK_MODE
  end
  if (group < 1 or group > 2) then
    return constants.ERROR_WRONG_GROUP_NUM
  end
  sendOneCommand("cmdSetState", {deviceAddress, group, value})
  return constants.ERROR_NO_ERROR
end

function readFromDevice()
  sendOneCommand("cmdReadState", {deviceAddress, 1})
  DriverLib.sleep(0.3)
  sendOneCommand("cmdReadState", {deviceAddress, 2})
  return constants.ERROR_NO_ERROR
end

function performScene(group)
  local curMode = DriverLib.get("workMode")
  if (curMode ~= 2) then
    return constants.ERROR_WRONG_WORK_MODE
  end
  if (group < 1 or group > 2) then
    return constants.ERROR_WRONG_GROUP_NUM
  end
  sendOneCommand("cmdSetState", {deviceAddress, group, 1})
  return constants.ERROR_NO_ERROR
end

function setDimmerLevel(value)
  local curMode = DriverLib.get("workMode")
  if (curMode ~= 3) then
    return constants.ERROR_WRONG_WORK_MODE
  end
   if (value < 0 or value > 63) then
    return constants.ERROR_WRONG_LEVLE_NUM
  end
  sendOneCommand("cmdSetState", {deviceAddress, 0, value})
  return constants.ERROR_NO_ERROR
end

function controlBlind(action)
  local curMode = DriverLib.get("workMode")
  if (curMode ~= 1) then
    return constants.ERROR_WRONG_WORK_MODE
  end
  local upRelay = DriverLib.get("blindUpRelay")
  if (action == "up") then
    sendOneCommand("cmdSetState", {deviceAddress, upRelay, 1})
    return constants.ERROR_NO_ERROR
  elseif (action == "down") then
    sendOneCommand("cmdSetState", {deviceAddress, 3-upRelay, 1})
    return constants.ERROR_NO_ERROR
  elseif (action == "stop") then
    sendOneCommand("cmdSetState", {deviceAddress, 1, 0})
    DriverLib.sleep(0.3)
    sendOneCommand("cmdSetState", {deviceAddress, 2, 0})
    return constants.ERROR_NO_ERROR
  end
  return constants.ERROR_WRONG_FUNCTION_CODE
end

function  PRX_CMD.ON(idBinding, tParams)
	print("From proxy " .. idBinding .. " command ON")
	local grpNo = (idBinding == 5001) and 1 or 2
	DriverLib.postMsg(controlDevice(grpNo, 1, {MODE_LIGHT,MODE_BLIND}))
end
function  PRX_CMD.OFF(idBinding, tParams)
	print("From proxy " .. idBinding .. " command OFF")
	local grpNo = (idBinding == 5001) and 1 or 2
	DriverLib.postMsg(controlDevice(grpNo, 0, {MODE_LIGHT,MODE_BLIND}))
end
function  PRX_CMD.SET_LIGHT_LEVEL(idBinding, tParams)
	print("From proxy " .. idBinding .. " command SET_LIGH_LEVEL: LEVEL=" .. tostring(tParams.LEVEL or "nil"))
	local level = tonumber(tParams.LEVEL or 63)
	local rst = setDimmerLevel(tonumber(level))
	Dbg:Error("Command SetDimmerLevel " .. rst)
end

function PRX_CMD.BUTTON_ACTION(idBinding, tParams)
	Dbg:Debug("handle button action(id=" .. idBinding .. ", BUTTON_ID=".. tParams.BUTTON_ID .. " , ACTION=" .. tParams.ACTION)
	local action = tonumber(tParams.ACTION)
	local buttonId = tonumber(tParams.ACTION)
	if (action == 1) then 
		Dbg:Debug("Ignore release button action")
		return
	else
		Dbg:Debug("Handle press button action")
	end
	local groupNo = (tonumber(idBinding) == 5001) and 1 or 2
	local info = config.iodef["light"..groupNo]
	local curState = Properties[info.propertyName] or "Close"
	if (curState == "Close") then
		controlDevice(groupNo, 1, {MODE_LIGHT})
		DriverLib.updateProperty(info, "Open")
		C4:SendToProxy(5000+groupNo,"LIGHT_LEVEL",100)
	else
		controlDevice(groupNo, 0, {MODE_LIGHT})
		DriverLib.updateProperty(info, "Close")
		C4:SendToProxy(5000+groupNo,"LIGHT_LEVEL",0)
	end
end

function EX_CMD.WhoAmI(tParams)
  local resp = {
	  deviceId = C4:GetDeviceID(),
	  profile = "SmartSwitchLight"
  }
  C4:SendToDevice(tParams.deviceId, "UpdateProfile", resp)
end
]]></script>
        <actions>
            <action>
                <name>Perform Scene 2</name>
                <command>PerformScene2</command>
            </action>
            <action>
                <name>Perform Scene 1</name>
                <command>PerformScene1</command>
            </action>
            <action>
                <name>Blind Down</name>
                <command>BlindDown</command>
            </action>
            <action>
                <name>Blind Stop</name>
                <command>BlindStop</command>
            </action>
            <action>
                <name>Blind Up</name>
                <command>BlindUp</command>
            </action>
            <action>
                <name>Close 2</name>
                <command>CloseGroup2</command>
            </action>
            <action>
                <name>Open 2</name>
                <command>OpenGroup2</command>
            </action>
            <action>
                <name>Close 1</name>
                <command>CloseGroup1</command>
            </action>
            <action>
                <name>Open 1</name>
                <command>OpenGroup1</command>
            </action>
            <action>
                <name>Check State</name>
                <command>CheckState</command>
            </action>
            <action>
                <name>Show Status</name>
                <command>ShowStatus</command>
            </action>
        </actions>
        <commands>
            <command>
                <name>SetRelay</name>
                <description>Control the relay of each group</description>
                <params>
                    <param>
                        <name>group</name>
                        <type>RANGED_INTEGER</type>
                        <readonly>False</readonly>
                        <default />
                        <minimum>1</minimum>
                        <maximum>2</maximum>
                    </param>
                    <param>
                        <name>state</name>
                        <type>LIST</type>
                        <readonly>False</readonly>
                        <default />
                        <items>
                            <item>Open</item>
                            <item>Close</item>
                        </items>
                    </param>
                </params>
            </command>
            <command>
                <name>PerformScene</name>
                <description>Perform the scene in smart switch</description>
                <params>
                    <param>
                        <name>group</name>
                        <type>RANGED_INTEGER</type>
                        <readonly>False</readonly>
                        <default />
                        <minimum>1</minimum>
                        <maximum>2</maximum>
                    </param>
                </params>
            </command>
            <command>
                <name>SetDimmerLevel</name>
                <description>This NAME is undefined</description>
                <params>
                    <param>
                        <name>level</name>
                        <type>RANGED_INTEGER</type>
                        <readonly>False</readonly>
                        <default />
                        <minimum>0</minimum>
                        <maximum>63</maximum>
                    </param>
                </params>
            </command>
        </commands>
        <properties>
            <property>
                <name>Debug Level</name>
                <type>LIST</type>
                <readonly>false</readonly>
                <default>2 - Warning</default>
                <items>
                    <item>0 - Alert</item>
                    <item>1 - Error</item>
                    <item>2 - Warning</item>
                    <item>3 - Info</item>
                    <item>4 - Trace</item>
                    <item>5 - Debug</item>
                </items>
            </property>
            <property>
                <name>Debug Mode</name>
                <type>LIST</type>
                <readonly>false</readonly>
                <default>Off</default>
                <items>
                    <item>Off</item>
                    <item>Print</item>
                    <item>Log</item>
                    <item>Print and Log</item>
                </items>
            </property>
            <property>
                <name>Address</name>
                <type>RANGED_INTEGER</type>
                <readonly>false</readonly>
                <default>10</default>
                <minimum>1</minimum>
                <maximum>255</maximum>
            </property>
            <property>
                <name>Use Serial Agent</name>
                <type>LIST</type>
                <readonly>false</readonly>
                <default>Yes</default>
                <items>
                    <item>Yes</item>
                    <item>No</item>
                </items>
            </property>
            <property>
                <name>Serial Agent Device ID</name>
                <type>RANGED_INTEGER</type>
                <readonly>false</readonly>
                <default>1</default>
                <minimum>0</minimum>
                <maximum>65535</maximum>
            </property>
            <property>
                <name>Dump Serial Data</name>
                <type>LIST</type>
                <readonly>false</readonly>
                <default />
                <items>
                    <item>Yes</item>
                    <item>No</item>
                </items>
            </property>
            <property>
                <name>Error Message</name>
                <type>STRING</type>
                <readonly>true</readonly>
                <default>SUCCESS</default>
            </property>
            <property>
                <name>Device Work Mode</name>
                <type>LIST</type>
                <readonly>true</readonly>
                <default>Light</default>
                <items>
                    <item>Light</item>
                    <item>Blind</item>
                    <item>Scene</item>
                    <item>Dimmer</item>
                </items>
            </property>
            <property>
                <name>Light 1 State</name>
                <type>STRING</type>
                <readonly>true</readonly>
                <default />
            </property>
            <property>
                <name>Light 2 State</name>
                <type>STRING</type>
                <readonly>true</readonly>
                <default />
            </property>
            <property>
                <name>Blind Up Relay</name>
                <type>RANGED_INTEGER</type>
                <readonly>false</readonly>
                <default>1</default>
                <minimum>1</minimum>
                <maximum>2</maximum>
            </property>
            <property>
                <name>Blind</name>
                <type>STRING</type>
                <readonly>true</readonly>
                <default />
            </property>
            <property>
                <name>Dimmer Level</name>
                <type>RANGED_INTEGER</type>
                <readonly>false</readonly>
                <default>0</default>
                <minimum>0</minimum>
                <maximum>63</maximum>
            </property>
        </properties>
    </config>
    <composer_categories>
        <category>Lighting</category>
    </composer_categories>
    <events>
        <event>
            <id>1</id>
            <name>Light 1 Open</name>
            <description>This NAME is undefined</description>
        </event>
        <event>
            <id>2</id>
            <name>Light 1 Close</name>
            <description>This NAME is undefined</description>
        </event>
        <event>
            <id>3</id>
            <name>Blind Up</name>
            <description>This NAME is undefined</description>
        </event>
        <event>
            <id>4</id>
            <name>Blind Down</name>
            <description>This NAME is undefined</description>
        </event>
        <event>
            <id>5</id>
            <name>Blind Stop</name>
            <description>This NAME is undefined</description>
        </event>
        <event>
            <id>6</id>
            <name>Dimer Level Changed</name>
            <description>This NAME is undefined</description>
        </event>
        <event>
            <id>7</id>
            <name>Light 2 Open</name>
            <description>This NAME is undefined</description>
        </event>
        <event>
            <id>8</id>
            <name>Light 2 Close</name>
            <description>This NAME is undefined</description>
        </event>
    </events>
</devicedata>