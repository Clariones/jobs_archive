<devicedata>
    <copyright>Copyright 2004-2008 Control4 Corporation.  All rights reserved.</copyright>
    <creator>SkyNet</creator>
    <manufacturer>HongSheng</manufacturer>
    <name>Air Cooled Chiller</name>
    <model>Model</model>
    <created>01/07/2016 10:04 AM</created>
    <modified>01/07/2016 1:47 PM</modified>
    <version>10</version>
    <small>devices_sm\c4.gif</small>
    <large>devices_lg\c4.gif</large>
    <control>lua_gen</control>
    <controlmethod>serial</controlmethod>
    <driver>DriverWorks</driver>
    <search_type>SkyNet</search_type>
    <combo>True</combo>
    <OnlineCategory>others</OnlineCategory>
    <proxies qty="1">
        <proxy>AirCooledChiller_232_HongSheng_Model</proxy>
    </proxies>
    <connections>
        <connection>
            <id>1</id>
            <facing>6</facing>
            <connectionname>Serial RS-232</connectionname>
            <type>1</type>
            <consumer>True</consumer>
            <audiosource>False</audiosource>
            <videosource>False</videosource>
            <linelevel>False</linelevel>
            <classes>
                <class>
                    <classname>RS_232</classname>
                </class>
            </classes>
        </connection>
		<connection>
            <id>2</id>
            <facing>1</facing>
            <connectionname>DATA_PROXY</connectionname>
            <type>1</type>
            <consumer>True</consumer>
            <audiosource>False</audiosource>
            <videosource>False</videosource>
            <linelevel>True</linelevel>
            <classes>
                <class>
                    <classname>DATA_PROXY</classname>
                    <autobind>True</autobind>
                </class>
            </classes>
        </connection>
    </connections>
    <config>
        <identify_text>Atmospheric Sensor NH122</identify_text>
        <power_management_method>AlwaysOn</power_management_method>
        <power_command_delay>0</power_command_delay>
        <power_delay>0</power_delay>
        <power_command_needed>False</power_command_needed>
        <serialsettings>9600 8 none 1 none </serialsettings>
        <documentation>
        </documentation>
        <script><![CDATA[--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-- Driver Declarations
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
--[[

  Command Handler Tables

--]]
EX_CMD = {}
PRX_CMD = {}
NOTIFY = {}
DEV_MSG = {}
LUA_ACTION = {}

--[[

Tables of functions
The following tables are function containers that are called within the following functions:  
  OnDriverInit()
    - first calls all functions contained within ON_DRIVER_EARLY_INIT table
    - then calls all functions contained within ON_DRIVER_INIT table

  OnDriverLateInit()
    - calls all functions contained within ON_DRIVER_LATEINIT table

  OnDriverUpdate()
    - calls all functions contained within ON_DRIVER_UPDATE table

  OnDriverDestroyed()
    - calls all functions contained within ON_DRIVER_DESTROYED table

  OnPropertyChanged()
    - calls all functions contained within ON_PROPERTY_CHANGED table

--]]
ON_DRIVER_INIT = {}
ON_DRIVER_EARLY_INIT = {}
ON_DRIVER_LATEINIT = {}
ON_DRIVER_UPDATE = {}
ON_DRIVER_DESTROYED = {}
ON_PROPERTY_CHANGED = {}

-- Constants
DEFAULT_PROXY_BINDINGID = 5001

--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-- Common Driver Code
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
--[[
  OnPropertyChanged
    Function called by Director when a property changes value.
  Parameters
    sProperty
      Name of property that has changed.

  Remarks
    The value of the property that has changed can be found with: Properties[sName]. Note
    that OnPropertyChanged is not called when the Property has been changed by the driver
    calling the UpdateProperty command, only when the Property is changed by the user from
    the Properties Page. This function is called by Director when a property changes value.
--]]
function OnPropertyChanged(sProperty)
  Dbg:Trace("OnPropertyChanged(" .. sProperty .. ") changed to: " .. Properties[sProperty])

  local propertyValue = Properties[sProperty]

  -- Remove any spaces (trim the property)
  local trimmedProperty = string.gsub(sProperty, " ", "")

  -- if function exists then execute (non-stripped)
  if (ON_PROPERTY_CHANGED[sProperty] ~= nil and type(ON_PROPERTY_CHANGED[sProperty]) == "function") then
    ON_PROPERTY_CHANGED[sProperty](propertyValue)
    return
    -- elseif trimmed function exists then execute
  elseif (ON_PROPERTY_CHANGED[trimmedProperty] ~= nil and type(ON_PROPERTY_CHANGED[trimmedProperty]) == "function") then
    ON_PROPERTY_CHANGED[trimmedProperty](propertyValue)
    return
  end

  PropertyHandlingSpecialist:onPropertyChanged(sProperty, propertyValue)
end

function ON_PROPERTY_CHANGED.DebugMode(propertyValue)
  gDebugTimer:KillTimer()
  Dbg:OutputPrint(propertyValue:find("Print") ~= nil)
  Dbg:OutputC4Log(propertyValue:find("Log") ~= nil)
  if (propertyValue == "Off") then return end
  gDebugTimer:StartTimer()
end

function ON_PROPERTY_CHANGED.DebugLevel(propertyValue)
  Dbg:SetLogLevel(tonumber(string.sub(propertyValue, 1, 1)))
end

---------------------------------------------------------------------
-- ExecuteCommand Code
---------------------------------------------------------------------
--[[

  ExecuteCommand
    Function called by Director when a command is received for this DriverWorks driver.
    This includes commands created in Composer programming.
  Parameters
    sCommand
      Command to be sent
    tParams
      Lua table of parameters for the sent command
--]]
function ExecuteCommand(sCommand, tParams)
  Dbg:Trace("ExecuteCommand(" .. sCommand .. ")")
  Dbg:Info(tParams)

  -- Remove any spaces (trim the command)
  local trimmedCommand = string.gsub(sCommand, " ", "")

  -- if function exists then execute (non-stripped)
  if (EX_CMD[sCommand] ~= nil and type(EX_CMD[sCommand]) == "function") then
    EX_CMD[sCommand](tParams)
    -- elseif trimmed function exists then execute
  elseif (EX_CMD[trimmedCommand] ~= nil and type(EX_CMD[trimmedCommand]) == "function") then
    EX_CMD[trimmedCommand](tParams)
    -- handle the command
  elseif (EX_CMD[sCommand] ~= nil) then
    QueueCommand(EX_CMD[sCommand])
  else
    Dbg:Alert("ExecuteCommand: Unhandled command = " .. sCommand)
  end
end

--[[

  Define any functions of commands (EX_CMD.<command>) received from ExecuteCommand that need to be handled by the driver.

--]]

--[[

  EX_CMD.LUA_ACTION

    Function called for any actions executed by the user from the Actions Tab in Composer.

--]]
function EX_CMD.LUA_ACTION(tParams)
  if tParams ~= nil then
    for cmd,cmdv in pairs(tParams) do
      if cmd == "ACTION" then
        if (LUA_ACTION[cmdv] ~= nil) then
          LUA_ACTION[cmdv]()
        elseif ActionHandlingSpecialist:canHandle(cmdv) then
          ActionHandlingSpecialist:doAction(cmdv)
        else
          Dbg:Alert("Undefined Action")
          Dbg:Alert("Key: " .. cmd .. " Value: " .. cmdv)
        end
      else
        Dbg:Alert("Undefined Command")
        Dbg:Alert("Key: " .. cmd .. " Value: " .. cmdv)
      end
    end
  end
end

--[[

  LUA_ACTION.DisplayGlobals
    Implementation of Action "Display Globals". Executed when selecting the "Display Globals" action within Composer.
    Provided as an example for actions.
--]]
function LUA_ACTION.DisplayGlobals()
  print ("Global Variables")
  print ("----------------------------")

  for k,v in pairs(_G) do -- globals`
    if not (type(v) == "function") then
      --print(k .. ":  " .. tostring(v))
      if (string.find(k, "^g%L")  == 1) then
        print(k .. ":  " .. tostring(v))
        if (type(v) == "table") then
          PrintTable(v, "   ")
        end
      end
  end
  end

  print ("")
end

function PrintTable(tValue, sIndent)
  sIndent = sIndent or "   "
  for k,v in pairs(tValue) do
    print(sIndent .. tostring(k) .. ":  " .. tostring(v))
    if (type(v) == "table") then
      PrintTable(v, sIndent .. "   ")
    end
  end
end

---------------------------------------------------------------------
-- ReceivedFromProxy Code
---------------------------------------------------------------------
--[[

  ReceivedFromProxy(idBinding, sCommand, tParams)
    Function called by Director when a proxy bound to the specified binding sends a
    BindMessage to the DriverWorks driver.
  Parameters
    idBinding
      Binding ID of the proxy that sent a BindMessage to the DriverWorks driver.
    sCommand
      Command that was sent
    tParams
      Lua table of received command parameters

--]]
function ReceivedFromProxy(idBinding, sCommand, tParams)
  if (sCommand ~= nil) then
    if(tParams == nil)    -- initial table variable if nil
    then tParams = {}
    end
    Dbg:Trace("ReceivedFromProxy(): " .. sCommand .. " on binding " .. idBinding .. "; Call Function " .. sCommand .. "()")
    Dbg:Info(tParams)

    if (PRX_CMD[sCommand]) ~= nil then
      PRX_CMD[sCommand](idBinding, tParams)
    else
      Dbg:Alert("ReceivedFromProxy: Unhandled command = " .. sCommand)
    end
  end
end

---------------------------------------------------------------------
-- Notification Code
---------------------------------------------------------------------
-- notify with parameters
function SendNotify(notifyText, Parms, bindingID)
  C4:SendToProxy(bindingID, notifyText, Parms, "NOTIFY")
end

-- A notify with no parameters
function SendSimpleNotify(notifyText, ...)
  bindingID = select(1, ...) or DEFAULT_PROXY_BINDINGID
  C4:SendToProxy(bindingID, notifyText, {}, "NOTIFY")
end

---------------------------------------------------------------------
-- Initialization/Destructor Code
---------------------------------------------------------------------
--[[

  OnDriverInit
    Invoked by director when a driver is loaded. This API is provided for the driver developer to contain all of the driver
    objects that will require initialization.

--]]
function OnDriverInit()
  C4:ErrorLog("INIT_CODE: OnDriverInit()")
  -- Call all ON_DRIVER_EARLY_INIT functions.
  for k,v in pairs(ON_DRIVER_EARLY_INIT) do
    if (ON_DRIVER_EARLY_INIT[k] ~= nil and type(ON_DRIVER_EARLY_INIT[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_EARLY_INIT." .. k .. "()")
      ON_DRIVER_EARLY_INIT[k]()
    end
  end

  -- Call all ON_DRIVER_INIT functions
  for k,v in pairs(ON_DRIVER_INIT) do
    if (ON_DRIVER_INIT[k] ~= nil and type(ON_DRIVER_INIT[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_INIT." .. k .. "()")
      ON_DRIVER_INIT[k]()
    end
  end

  -- Fire OnPropertyChanged to set the initial Headers and other Property global sets, they'll change if Property is changed.
  for k,v in pairs(Properties) do
    OnPropertyChanged(k)
  end
  
  DriverInitialed = true
  
end

--[[

  OnDriverUpdate
    Invoked by director when an update to a driver is requested. This request can occur either by adding a new version of a driver
    through the driver search list or right clicking on the driver and selecting "Update Driver" from within ComposerPro.

--]]
function OnDriverUpdate()
  C4:ErrorLog("INIT_CODE: OnDriverUpdate()")

  -- Call all ON_DRIVER_UPDATE functions
  for k,v in pairs(ON_DRIVER_UPDATE) do
    if (ON_DRIVER_UPDATE[k] ~= nil and type(ON_DRIVER_UPDATE[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_UPDATE." .. k .. "()")
      ON_DRIVER_UPDATE[k]()
    end
  end
end

--[[

  OnDriverLateInit
    Invoked by director after all drivers in the project have been loaded. This API is provided
    for the driver developer to contain all of the driver objects that will require initialization
    after all drivers in the project have been loaded.

--]]
function OnDriverLateInit()
  C4:ErrorLog("INIT_CODE: OnDriverLateInit()")

  -- Call all ON_DRIVER_LATEINIT functions
  for k,v in pairs(ON_DRIVER_LATEINIT) do
    if (ON_DRIVER_LATEINIT[k] ~= nil and type(ON_DRIVER_LATEINIT[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_LATEINIT." .. k .. "()")
      ON_DRIVER_LATEINIT[k]()
    end
  end
end


--[[

  OnDriverDestroyed

    Function called by Director when a driver is removed. Release things this driver has allocated such as timers.

--]]
function OnDriverDestroyed()
  C4:ErrorLog("INIT_CODE: OnDriverDestroyed()")
  -- Call all ON_DRIVER_DESTROYED functions
  for k,v in pairs(ON_DRIVER_DESTROYED) do
    if (ON_DRIVER_DESTROYED[k] ~= nil and type(ON_DRIVER_DESTROYED[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_DESTROYED." .. k .. "()")
      ON_DRIVER_DESTROYED[k]()
    end
  end
end

--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-- Debug Logging Code
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Log = {}

-- Create a Table with Logging functions
function Log:Create()

  -- table for logging functions
  local lt = {}

  lt._logLevel = 0
  lt._outputPrint = false
  lt._outputC4Log = false
  lt._logName =  "Set Log Name to display"

  function lt:SetLogLevel(level)
    self._logLevel = level
  end

  function lt:OutputPrint(value)
    self._outputPrint = value
  end

  function lt:OutputC4Log(value)
    self._outputC4Log = value
  end

  function lt:SetLogName(name)
    self._logName = name
  end

  function lt:Enabled()
    return (self._outputPrint or self._outputC4Log)
  end

  function lt:PrintTable(tValue, sIndent)
    if (type(tValue) == "table") then
      if (self._outputPrint) then
        for k,v in pairs(tValue) do
          print(sIndent .. tostring(k) .. ":  " .. tostring(v))
          if (type(v) == "table") then
            self:PrintTable(v, sIndent .. "   ")
          end
        end
      end

      if (self._outputC4Log) then
        for k,v in pairs(tValue) do
          C4:ErrorLog(self._logName .. ": " .. sIndent .. tostring(k) .. ":  " .. tostring(v))
          if (type(v) == "table") then
            self:PrintTable(v, sIndent .. "   ")
          end
        end
      end

    else
      if (self._outputPrint) then
        print (sIndent .. tValue)
      end

      if (self._outputC4Log) then
        C4:ErrorLog(self._logName .. ": " .. sIndent .. tValue)
      end
    end
  end

  function lt:Print(logLevel, sLogText)
    if (self._logLevel >= logLevel) then
      if (type(sLogText) == "table") then
        self:PrintTable(sLogText, "   ")
        return
      end

      if (self._outputPrint) then
        print (sLogText)
      end

      if (self._outputC4Log) then
        C4:ErrorLog(self._logName .. ": " .. sLogText)
      end
    end
  end

  function lt:Alert(strDebugText)
    self:Print(0, strDebugText)
  end

  function lt:Error(strDebugText)
    self:Print(1, strDebugText)
  end

  function lt:Warn(strDebugText)
    self:Print(2, strDebugText)
  end

  function lt:Info(strDebugText)
    self:Print(3, strDebugText)
  end

  function lt:Trace(strDebugText)
    self:Print(4, strDebugText)
  end

  function lt:Debug(strDebugText)
    self:Print(5, strDebugText)
  end

  return lt
end

function ON_DRIVER_EARLY_INIT.LogLib()
  -- Create and initialize debug logging
  Dbg = Log.Create()
  Dbg:SetLogName("SmartSwitch")
end

function ON_DRIVER_INIT.LogLib()
  -- Create Debug Timer
  gDebugTimer = Timer:Create("Debug", 45, "MINUTES", OnDebugTimerExpired)
end

--[[

  OnDebugTimerExpired
    Debug timer callback function

--]]
function OnDebugTimerExpired()
  Dbg:Warn("Turning Debug Mode Off (timer expired)")
  gDebugTimer:KillTimer()
  C4:UpdateProperty("Debug Mode", "Off")
  OnPropertyChanged("Debug Mode")
end

---------------------------------------------------------------------
-- Timer Code
---------------------------------------------------------------------
Timer = {}

-- Create a Table with Timer functions
function Timer:Create(name, interval, units, Callback, repeating, Info)
  -- timers table
  local tt = {}

  tt._name = name
  tt._timerID = TimerLibGetNextTimerID()
  tt._interval = interval
  tt._units = units
  tt._repeating = repeating or false
  tt._Callback = Callback
  tt._info = Info or ""
  tt._id = 0

  function tt:StartTimer(...)
    self:KillTimer()

    -- optional parameters (interval, units, repeating)
    if ... then
      local interval = select(1, ...)
      local units = select(2, ...)
      local repeating = select(3, ...)

      self._interval = interval or self._interval
      self._units = units or self._units
      self._repeating = repeating or self._repeating
    end

    if (self._interval > 0) then
      Dbg:Trace("Starting Timer: " .. self._name)
      self._id = C4:AddTimer(self._interval, self._units, self._repeating)
    end
  end

  function tt:KillTimer()
    if (self._id) then
      self._id = C4:KillTimer(self._id)
    end
  end

  function tt:TimerStarted()
    return (self._id ~= 0)
  end

  function tt:TimerStopped()
    return not self:TimerStarted()
  end

  gTimerLibTimers[tt._timerID] = tt
  Dbg:Trace("Created timer " .. tt._name)

  return tt
end

function TimerLibGetNextTimerID()
  gTimerLibTimerCurID = gTimerLibTimerCurID + 1
  return gTimerLibTimerCurID
end

function ON_DRIVER_EARLY_INIT.TimerLib()
  gTimerLibTimers = {}
  gTimerLibTimerCurID = 0
end

function ON_DRIVER_DESTROYED.TimerLib()
  -- Kill open timers
  for k,v in pairs(gTimerLibTimers) do
    v:KillTimer()
  end
end

--[[

  OnTimerExpired
    Function called by Director when the specified Control4 timer expires.
  Parameters
    idTimer
      Timer ID of expired timer.

--]]
function OnTimerExpired(idTimer)
  for k,v in pairs(gTimerLibTimers) do
    if (idTimer == v._id) then
      if (v._Callback) then
        v._Callback(v._info)
      end
    end
  end
end


------------------------------------------------------------------------
-- Below are driver common scripts. It's almost same to all serial-bus-controlled driver.
-- Will do below:
-- 1. First of all, declare several important status variable
-- 2. Add properties change handler
-- 3. Add "show status" command handler
-- 4. Add code for using or not using serial agent
-- 5. Add error message display method

local COMMON_CONSTANT = {
  COMM_WITH_SERIAL_AGENT = "comm-by-serial-agent",
  COMM_WITH_SERIAL_PORT = "comm-by-serial-port"
}
DriverInitialed = false
--- Serial communication address for current device
deviceAddress = 1
--- communication mode. 1- use serial-agent driver, 2- directly use serial port
local communicationMode
local serialAgentDevId = 1
local oldSerialAgentDevId = 1
--- print binary serial data package or not
local isDumpSerialData = true
--- buffer for framed receving-command strings
local recvFrameDatas = {}
--- framing timer
local framingTimer
local frameingTimerCnt = 0

--- action commond
function LUA_ACTION.ShowStatus()
  print("Device address  is " .. deviceAddress)
  print("Communication mode is " .. communicationMode)
  print("Serial Agent device ID is " .. serialAgentDevId)
  print("Dump serial data is " .. tostring(isDumpSerialData))
  print("Polling task is " .. (pollingTimer:TimerStarted() 
    and "Every " .. Properties["Polling Seconds"] .. " seconds"
    or "not started"))
  PropertyHandlingSpecialist:printAllProperties() 
end

--- Common property on-change handlers
ON_PROPERTY_CHANGED["Use Serial Agent"] = function(propValue)
  if (propValue == "Yes") then
    communicationMode = COMMON_CONSTANT.COMM_WITH_SERIAL_AGENT
  else
    communicationMode = COMMON_CONSTANT.COMM_WITH_SERIAL_PORT
  end
  Dbg:Info("Set communication mode to "..(isDumpSerialData and "Yes" or "No"))
  RebindSerialAgent()
end

ON_PROPERTY_CHANGED["Address"] = function(propValue)
  deviceAddress = tonumber(propValue)
  Dbg:Info("Set device self serial communication address to "..deviceAddress)
end

ON_PROPERTY_CHANGED["Dump Serial Data"] = function(propValue)
  isDumpSerialData = propValue == "Yes"
  Dbg:Info("Set dump serial data to "..(isDumpSerialData and "Yes" or "No"))
end

ON_PROPERTY_CHANGED["Serial Agent Device ID"] = function(propValue)
  serialAgentDevId = tonumber(propValue)
  Dbg:Info("Serial agent used is "..serialAgentDevId)
  RebindSerialAgent()
end

ON_PROPERTY_CHANGED["Polling Seconds"] = function(propValue)
  if (pollingTimer) then
    pollingTimer:KillTimer()
  end

  local timeIntv = tonumber(propValue)
  if (timeIntv <= 0) then
    Dbg:Info("Illumination polling schedule is closed")
    return
  end

  pollingTimer = Timer:Create("polling timer", timeIntv, "SECONDS", pollingTask, true, "polling timer")
  pollingTimer:StartTimer()
end

--- Common functions for comminication
--- register with serial-agent variables
function RebindSerialAgent()
  C4:UnregisterVariableListener(oldSerialAgentDevId, 1002)
  Dbg:Info("Release old binded serial agent "..oldSerialAgentDevId)
  oldSerialAgentDevId = serialAgentDevId
  if (serialAgentDevId > 0 and communicationMode == COMMON_CONSTANT.COMM_WITH_SERIAL_AGENT) then
    C4:RegisterVariableListener(serialAgentDevId, 1002)
    Dbg:Info("Bind me to serial agent "..serialAgentDevId)
  end
end
--- hanlde serial-agent notification
function OnWatchedVariableChanged(idDevice, idVariable, strValue)
  if (idDevice == serialAgentDevId and idVariable==1002 and communicationMode == COMMON_CONSTANT.COMM_WITH_SERIAL_AGENT) then
    OnRecieveFromSerialAgent(strValue)
  end
end

--- forward data received from serial-agent
function OnRecieveFromSerialAgent(strDataSeq)
  if (not strDataSeq) then
    return
  end
  local numDataSeq = tonumber(strDataSeq)
  if (not numDataSeq or numDataSeq < 1002) then
    return
  end
  local recvStr = C4:GetDeviceVariable(serialAgentDevId, numDataSeq)
  local strData = C4:Base64Decode(recvStr)
  if (isDumpSerialData) then
    print("\n\n\nReceive below data from serial agent:")
    hexdump(strData)
  end
  OnSerialDataReceived(strData)
end
--- handle data received from serial port
function ReceivedFromSerial(idBinding, strData)
  if strData == nil then
    return
  end
  if (communicationMode ~= COMMON_CONSTANT.COMM_WITH_SERIAL_PORT) then
    return
  end

  table.insert(recvStrDatas, strData)
  if (#strData < pieceSize) then
    frameingTimerCnt = 0
    handleFrameData()
  else
    frameingTimerCnt = 3
  end
end

function cutdownTimer()
  if (frameingTimerCnt == 0) then
    return
  end
  frameingTimerCnt = frameingTimerCnt - 1
  if (frameingTimerCnt <= 0) then
    handleFrameData()
  end
end

-- when found a whole piece frame data, send out the signal
function handleFrameData()
  local str = "";
  local len = #recvStrDatas
  if (len < 1) then
    return
  end

  for k=1,len do
    str =  str .. recvStrDatas[k]
  end
  recvStrDatas = {}

  if (isDumpSerialData) then
    print("\n\n\nReceive below data from serial port")
    hexdump(strData)
  end
  OnSerialDataReceived(strData)
end


function ON_DRIVER_INIT.driverCommonInit()
  framingTimer = Timer:Create("framing timer", 10, "MILLISECONDS", OnTestTimer, true, "framing timer")
  framingTimer:StartTimer()
  RebindSerialAgent()
  pollingTimer = Timer:Create("polling timer", 10, "SECONDS", readLumination, true, "polling timer")
  pollingTimer:StartTimer()
end
----------------------------------------------------------------------------


function SendCommand(strData)

  if communicationMode == COMMON_CONSTANT.COMM_WITH_SERIAL_PORT then
    C4:SendToSerial(1, strData)
    if (isDumpSerialData) then
      print("\n\n\nSend below data to serial port")
      hexdump(strData)
    end
    return
  end

  local base64Str = C4:Base64Encode(strData)
  C4:SendToDevice(serialAgentDevId, "SendCommand", {strData=base64Str})
  if (isDumpSerialData) then
    print("Send below data to serial agent")
    hexdump(strData)
  end
end


----------------------------------------------------------------------------
DriverLib = {configData=nil}
function DriverLib.getSortedKeys(tbl)
  local keyTbl = {}
  for k,v in pairs(tbl) do
    table.insert(keyTbl,k)
  end
  table.sort(keyTbl)
  return keyTbl
end
function DriverLib.tableToString(tbl, prefix)
  local rstStr = "{"
  prefix = prefix or ""
  local keyTbl = DriverLib.getSortedKeys(tbl)
  for i,k in pairs(keyTbl) do
    local v = tbl[k]
    if (type(v) == "table") then
      rstStr = rstStr .. prefix .. k .. DriverLib.tableToString(v, prefix .. "    ")
    else
      if (rstStr ~= "{") then
        rstStr = rstStr .. ", "
      end
      rstStr = rstStr .. prefix .. k .. "="
      if (type(v) == "string") then
        rstStr = rstStr .. "\"" .. tostring(v or "nil") .. "\""
      else
        rstStr = rstStr .. tostring(v or "nil")
      end
    end
  end
  return rstStr .. "}"
end
function DriverLib.sleep(timeSec)
  socket.select(nil, nil, timeSec)
end

function DriverLib.setConfig(data)
  DriverLib.configData = data
end

function DriverLib.postMsg(msg)
  C4:UpdateProperty("Error Message", msg)
  Dbg:Warn(msg)
end
function DriverLib.log(msg)
  Dbg:Info(msg)
end

function DriverLib.setList(info, propertyValue)
  if (info.propertyList == nil) then
    DriverLib.postMsg("[Error]: " .. info.displayName .. " has not defined List property")
    return
  end
  if (info.propertyList[propertyValue] == nil) then
    DriverLib.postMsg("[Error]: " .. info.displayName .. " has no value defined for " .. propertyValue .. " in the List")
    return
  end
  info.value = info.propertyList[propertyValue]
  DriverLib.log("[Log  ]: " .. info.displayName .. " set to " .. tostring(info.value))
end

function DriverLib.setNumber(info, propertyValue)
  info.value = tonumber(propertyValue)
end

function DriverLib.setString(info, propertyValue)
  info.value = tostring(propertyValue)
end

function DriverLib.readOnly(info, propertyValue)
  DriverLib.postMsg("[Error]: " .. info.displayName .. " is readonly")
end

function DriverLib.fireEvent(info, eventName)
  DriverLib.log("[EVENT OCCURRED]: " .. eventName)
  C4:FireEvent(eventName)
end

function DriverLib.updateProperty(info, value)
  DriverLib.log("Set " .. info.propertyName .. " to " .. tostring(value or "nil"))
  C4:UpdateProperty(info.propertyName, value)
  if (info.propertyList == nil) then
    info.value = value
    return
  end
  DriverLib.setList(info, value)
end

function DriverLib.onPropertyChanged(propName, propValue)
  for k,info in pairs(config.iodef) do
    if info.propertyName == propName then
      info.propertyHandler(info, propValue)
    end
  end
end

function DriverLib.printProperties()
  for k,info in pairs(DriverLib.configData.iodef) do
    print("The [" .. info.displayName .. "] is " .. tostring(info.value or "nil"))
  end
end

function DriverLib.get(name)
  return DriverLib.configData.iodef[name].value
end

function DriverLib.byte0 (data)
  return bit.band(data, 0xFF)
end

function DriverLib.byte1 (data)
  return bit.band(bit.rshift(data, 8), 0xFF)
end

function DriverLib.crc16 (buf, length)
  local crc = 0x0000ffff;
  local len = length or #buf
  for byte=1, len do
    local curByte = string.byte(buf,byte,byte)
    crc = bit.band(bit.bxor(crc, curByte), 0xFFFF)
    for j=1,8,1 do
      local f = bit.band(crc, 1)
      crc = bit.band(bit.rshift(crc, 1), 0x7FFF)
      if (f > 0) then
        crc = bit.bxor(crc, 0xa001)
      end
    end
  end
  -- 485 CRC is low-byte first, high-byte then
  return string.char(DriverLib.byte0(crc))..string.char(DriverLib.byte1(crc))
end

function DriverLib.verifyCrc16 (strData, numLen)
  numLen = numLen or #strData
  local calcCrc = DriverLib.crc16(strData, numLen-2)
  local recvCrc = string.sub(strData, numLen-1,numLen)
  return calcCrc == recvCrc
end

function DriverLib.toUShort (strData)
  local rst = 0;
  local byte0, byte1 = string.byte(strData,1,2)
  return byte0 * 256 + byte1
end

function DriverLib.toShort (strData)
  local rst = DriverLib.toUShort(strData)
  if (rst > 0x7FFF) then
    return rst - 0x10000
  end
  return rst
end
function DriverLib.lrc8(strData, len)
  len = len or #strData
  local lrc = 0
  for i=1,len do
    lrc = lrc + string.byte(strData,i,i)
  end
  return string.char(bit.band(lrc, 0xFF))
end
function DriverLib.lrc16(strData, len)
  len = len or #strData
  local lrc = 0
  for i=1,len do
    lrc = lrc + string.byte(strData,i,i)
  end
  return string.char(DriverLib.byte1(lrc), DriverLib.byte0(lrc))
end

PropertyHandlingSpecialist = {
  changeTolerance = "ChangeTolerance",
  fatal =   function (msg) print("!!!---FATAL-" .. msg) end,
  error =   function (msg) print("!!----ERROR-" .. msg) end,
  warning = function (msg) print("!---WARNING-" .. msg) end,
  info =    function (msg) print("-------INFO-" .. msg) end,
  debug =   function (msg) print("_-----DEBUG-" .. msg) end,

  infor = {},
  nameMap = {},
  outputVariables = {},

  printAllProperties = function(self)
    for k,v in pairs(self.infor) do
      if (v.bindToProperty) then
        print("Property " .. v.bindToProperty .. " is " .. tostring(v.value or "nil"))
      end
    end
  end,
  
  accept = function(self, nameMap, infoTable)
    print(self, nameMap, infoTable)
    self.infor = infoTable
    self.nameMap = nameMap
    self.outputVariables = {}
    local varKeys = {}
    -- add all UI-property:driver-property mapping from driver properties table
    for name, info in pairs(infoTable) do
      local uiName = info.bindToProperty
      if (uiName ~= nil and nameMap[uiName] == nil) then
        nameMap[uiName] = name
      end
      if (info.outputName ~= nil) then
          self.outputVariables[info.outputName] = name
          table.insert(varKeys, info.outputName)
      end
    end
    -- verify and fill default value for all driver properties
    for uiName, interName in pairs(nameMap) do
      local info = infoTable[interName]
      if (info == nil) then
        self.fatal(string.format("Property info [%s]:[%s] not defined", uiName, interName))
      else
        info["propertyName"] = uiName
        if (info.readOnly == nil) then info["readOnly"] = false end
        if (info.dataType == nil) then self.fatal("You must provide data type for " .. interName) end
        if (info.landmarkEvent ~= nill) and (type(info.landmarkCondition) ~= "function") then
          self.fatal("You must provide landMarkCondition function for " .. interName)
        end
        
      end
    end
    
    -- add variables to C4
    table.sort(varKeys)
    for i,name in pairs(varKeys) do
      local value = "NA"
      local varType = "STRING"
      local info = self.infor[self.outputVariables[name]]
      if (info.dataType == "int") or (info.dataType == "float") then
        varType = "NUMBER"
        value = 0
      end
      self.outputVariables[name] = value
      print("Add variable[" ..(1000+i).."] " .. name .. " with value [" .. value .."]")
      C4:AddVariable(name, value, varType)
    end
  end,

  updateProperty = function(self, name, value)
    local info = self.infor[name]
    
    if type(info.onDeviceValueUpdated) == "function" then
      info:onDeviceValueUpdated(name, value)
      return
    end
    -- check if need fire change event
    if (info.changeEvent ~= nil) then
      self:handleChangeEvent(info, name, value)
    end
    -- check if need fire landmark event
    if (info.landmarkEvent ~= nil) then
      self:handleLandmarkEvent(info, name, value)
    end
        
    -- last step, change the UI display
    info["value"] = value
    local outputValue = value
    if (info.dataType == "int") then
      outputValue = tonumber(value)
    elseif (info.dataType == "float") then
      outputValue = tonumber(value)
    elseif (info.dataType == "string") then
      outputValue = tostring(value)
    elseif (info.dataType == "list") then
      for k,v in pairs(info.valueList) do
        if (v == value) then
          outputValue = tostring(k)
          break
        end
      end
    end
    if (info.bindToProperty ~= nil) then
      C4:UpdateProperty(info.bindToProperty, outputValue)
    end
    
    if (info.outputName ~= nil) then
      self:updateOutputVariable(info.outputName, outputValue)
    end
  end,
  
  updateOutputVariable = function(self, name, value)
    local oldValue = self.outputVariables[name]
    if oldValue == value then return end
    self.outputVariables[name] = value
    Dbg:Info("Update output variable " .. name .. " to " .. value)
    C4:SetVariable(name, value)
  end,
  
  handleChangeEvent = function(self, info, name, value)
    if (info.changeEventType == "variation range") then
      if (info.lastTimeChangedValue == nil) then
        info["lastTimeChangedValue"] = value
        return
      end
      local oldValue = info.lastTimeChangedValue
      local limitVal = self:getPropertyValue(name .. self.changeTolerance)
      if (limitVal == nil) then
        self.fatal("Please check if you have property " .. name .. self.changeTolerance .. " defined")
        return
      end
      if (limitVal <= 0) then
        -- if set the delta to 0, or -1, no change event will be triggered
        info.lastTimeChangedValue = value
        return
      end
      if (math.abs(value - oldValue) >= limitVal) then
        info.lastTimeChangedValue = value
        DriverLib.fireEvent(info,info.changeEvent)
      end
    end
    
    if (info.changeEventType == "different") then
      if (info.value == nil) then
        info["value"] = value
        return
      end
      if (info.value == value) then return end
      info.value = value
      DriverLib.fireEvent(info,info.changeEvent)
    end
  end,
  
  handleLandmarkEvent = function(self, info, name, value)
    local hasMark = info:landmarkCondition(name, value)
    local oldMark = info["landmarkState"]
    if oldMark == hasMark then return end
    info.landmarkState = hasMark
    if hasMark == true then
      DriverLib.fireEvent(info,info.landmarkEvent[1])
    else
      DriverLib.fireEvent(info,info.landmarkEvent[2])
    end
  end,
  
  handlers = {
    ["float"] = "defaultNumberPropertyHandler",
    ["int"] = "defaultNumberPropertyHandler",
    ["list"] = "defaultListPropertyHandler",
    ["string"] = "defaultStringPropertyHandler",
  },

  defaultNumberPropertyHandler = function(info, name, value)
    local numVal = tonumber(value)
    if (type(info.range) == "table") then
      if (numVal < info.range[1] or numVal > info.range[2]) then
        return string.format("%s value should between {%d,%d} but %d", name, info.range[1], info.range[2], numVal)
      end
    end
    info["value"] = tonumber(value)
  end,
  defaultListPropertyHandler = function(info, name, value)
    if (info.valueList == nil) then return "Driver variable " .. name .. " has not defined LIST" end
    if (info.valueList[value] == nil) then return "Driver variable " .. name .. " has not defined value" .. value end
    info["value"] = info.valueList[value]
  end,
  defaultStringPropertyHandler = function(info, name, value)
    info["value"] = tostring(value)
  end,
  getDefaultPropertyHandler = function(self, dataType)
    return self[self.handlers[dataType]]
  end,
  getPropertyValue = function(self, propName, attrName)
    local info = self.infor[propName]
    if (not info) then return nil end
    return info.value
  end,
  getPropertyAttribute = function(self, propName, attrName)
    local info = self.infor[propName]
    return info[attrName]
  end,

  onPropertyChanged = function(self, propName, strValue)
    local strName = self.nameMap[propName]
    if strName == nil then print("You don't provides handler for " .. propName) return end
    local info = self.infor[strName]
    if (not info) then self.fatal("You must handler property " .. strName) return end
    local handler = info.onPropertyValueUpdated
    if (not handler) then
      if info.readOnly then print() end
      handler = self:getDefaultPropertyHandler(info.dataType)
      if handler == nil then self.fatal("Don't have default handler for type " .. info.dataType .. " for property" .. strName) return end
    end
    local rst = handler(info, strName, strValue)
    if (rst ~= nil) then self.error(rst) return end
    ----self.debug("^_^ : set property " .. strName .. " to " .. tostring(info.value))
  end
}

print("I'm going to create ActionHandlingSpecialist")
ActionHandlingSpecialist = {
  actionTable = {},
  
  accept = function(self, actionTable)
    self.actionTable = actionTable
  end,
  
  canHandle = function(self, name)
    return self.actionTable[name] ~= nil
  end,
  
  doAction = function(self, name)
    local info = self.actionTable[name]
    local tParams = self:makeFunCallParam(info.params)
    DriverLib.postMsg(info.callFunc(tParams))
  end,
  
  makeFunCallParam = function(self, paramTbl)
    if paramTbl == nil then return {} end
    
    local tParams = {}
    for id, infoTbl in pairs(paramTbl) do
      if (infoTbl.value) then
        table.insert(tParams, infoTbl.value)
      elseif (infoTbl.propertyAttr) then
        local val = PropertyHandlingSpecialist:getPropertyAttribute(infoTbl.propertyName, infoTbl.propertyAttr)
        table.insert(tParams, val)
      elseif (infoTbl.propertyName) then
        local val = PropertyHandlingSpecialist:getPropertyValue(infoTbl.propertyName)
        table.insert(tParams, val)
      end
    end
    return tParams
  end,
}

--require("AllSameScript")
-----------------------------------------------------------------------
-- Above codes are driver common scripts
-- Below is mine
----------------------------------------------------------------------------
-- below are examples you need to write by yourself
local sendProcess
local taskQueue = {}
local moduleSpecialProps = {}
function OnSerialDataReceived(strData)
  -- TODO: this is the unified response-data-handling-enter-point
  -- Please add your own logical from here
  if (type(strData) ~= "string") then return end
  if (#strData < 4) then return end
  local byte1, byte2 = string.byte(strData,1,2)
  if (byte1 ~= deviceAddress)  then return end
  handleCommandResponse(1, strData)
end

function pollingTask()
  queryAllStatus()
end
function grableAllModuleSpecialPropName()
  moduleSpecialProps = {}
  for name,info in pairs(Mine_driverVars) do
    if (info.pc_repeatTimes ~= nill) and (info.moduleNo == nil) then
      table.insert(moduleSpecialProps, name)
    end
  end
end
function showValueToUI(info, propName, value)
  local mNo = tonumber(value)
  if mNo == nil then mNo = 1 end
  local propMap = {}
  for i,name in pairs(moduleSpecialProps) do
    local tgtName = calcModuleName(name, mNo)
    propMap[name] = PropertyHandlingSpecialist:getPropertyValue(tgtName, "value")
  end
  for k,v in pairs(propMap) do
    PropertyHandlingSpecialist:updateProperty(k,v)
  end
end
local addressLookupTable = {}

local list_RunStop= {["Running"]=1, ["Stop"]=0}
local list_AlarmOrNot= {["Alarm"]=1, ["No Alarm"]=0}
local list_YesNo= {["Yes"]=1, ["No"]=0}
local list_OnOff= {["On"]=1, ["OFF"]=0}
function calcValue1Reg(info, name) return allRegValues[info.regAddrs[1]] end
function calcValueModuleCompressorState(info, name)
  local rst = ""
  for i=1,#(info.regAddrs) do
    local value = allRegValues[info.regAddrs[i]]
    rst = rst .. string.format("[%d]=%s, ", i , (value==1 and "Run" or "Stop") )
  end
  return rst
end
function calcValueModuleDefrostRunning(info, name)
  local rst = ""
  for i=1,#(info.regAddrs) do
    local value = allRegValues[info.regAddrs[i]]
    rst = rst .. string.format("[%d]=%s, ", i , (value==1 and "Yes" or "No") )
  end
  return rst
end

function calcValueModuleFaultCode(info, name)
  local rst = ""
  local startAddress = info.regAddrs[1] - 1
  for i=1,#(info.regAddrs) do
    local addr = info.regAddrs[i]
    local value = allRegValues[addr] --TODO
    if (value == 1) then
      rst = rst .. (addr-startAddress) .. ":" .. addressLookupTable[addr].varName .. " "
    end
  end
  if (rst:len() == 0) then rst = "No Alarm" end
  return rst
end

function calcValueUnitsTemperature(info, name)
  local rst = ""
  for i=1,#(info.regAddrs) do
    local value = allRegValues[info.regAddrs[i]]
    rst = rst .. string.format("[%d]=%2.1f, ",i,value)
  end
  return rst
end
function calcModuleCompressorCurrent(info, name)
  local rst = ""
  for i=1,#(info.regAddrs) do
    local value = allRegValues[info.regAddrs[i]]
    rst = rst .. string.format("[%d]=%2.1fA, ",i,value)
  end
  return rst
end

Mine_driverVars = {
  -------------- below are chiller whole unit level states ---------------------------
  ChillerRunningState = {
    bindToProperty = "Chiller Running State",
    outputName = "Chiller Running State",
    dataType = "list",
    valueList = list_RunStop,
    readOnly = true,
    landmarkEvent = {"Chiller Started", "Chiller Stopped"},
    landmarkCondition = function(info, name, newValue) return newValue == 1 end,
    calcValueFunc = calcValue1Reg,
  },
  ChillerAntifreezingState = {
    bindToProperty = "Chiller Antifreezing State",
    outputName = "Chiller Antifreezing State",
    dataType = "list",
    valueList = list_RunStop,
    readOnly = true,
    landmarkEvent = {"Chiller Antifreezing Started", "Chiller Antifreezing Stopped"},
    landmarkCondition = function(info, name, newValue) return newValue == 1 end,
    calcValueFunc = calcValue1Reg,
  },
  ChillerFaultState = {
    bindToProperty = "Chiller Fault State",
    outputName = "Chiller Fault State",
    dataType = "list",
    valueList = list_AlarmOrNot,
    readOnly = true,
    landmarkEvent = {"Chiller Has Fault", "Chiller Fault clear"},
    landmarkCondition = function(info, name, newValue) return newValue == 1 end,
    calcValueFunc = calcValue1Reg,
  },
  ChillerWorkingMode = {
    bindToProperty = "Chiller Working Mode",
    outputName = "Chiller Working Mode",
    dataType = "list",
    valueList = {["Cool"] = 0, ["Heat"] = 1},
    readOnly = true,
    calcValueFunc = calcValue1Reg,
  },
  ChillerOilPreheatingState = {
    bindToProperty = "Oil pre-Heating State",
    outputName = "Oil pre-Heating State",
    dataType = "list",
    valueList = list_YesNo,
    readOnly = true,
    calcValueFunc = calcValue1Reg,
  },
  ChillerWaterPumpState = {
    bindToProperty = "AC Water Pump State",
    outputName = "AC Water Pump State",
    dataType = "list",
    valueList = list_OnOff,
    readOnly = true,
    calcValueFunc = calcValue1Reg,
  },
  ChillerAuxiliaryHeatingState = {
    bindToProperty = "Auxiliary Heating State",
    outputName = "Auxiliary Heating State",
    dataType = "list",
    valueList = list_OnOff,
    readOnly = true,
    calcValueFunc = calcValue1Reg,
  },
  -------------- below are module level states ---------------------------
  ModuleIOBoardOutput = {
    pc_repeatTimes = 8,
    bindToProperty = "Module IO Board Output",
    outputName = "Module IO Board Output",
    dataType = "list",
    valueList = list_AlarmOrNot,
    readOnly = true,
    landmarkEvent = {"Module IO Board Alarm", "Module IO Board Clear"},
    landmarkCondition = function(info, name, newValue) return newValue == 1 end,
    value = list_AlarmOrNot[0],
    calcValueFunc = calcValue1Reg,
  },
  ModuleCompressorState = {
    pc_repeatTimes = 8,
    bindToProperty = "Module Compressor State",
    outputName = "Module Compressor State",
    dataType = "string",
    readOnly = true,
    changeEvent = "Module Compressor State Changed",
    changeEventType = "different",
    value = "all stop",
    calcValueFunc = calcValueModuleCompressorState,
  },
  ModuleDefrostRunning = {
    pc_repeatTimes = 8,
    bindToProperty = "Module Defrost Running",
    outputName = "Module Defrost Running",
    dataType = "string",
    readOnly = true,
    changeEvent = "Module Defrost Running Units",
    changeEventType = "different",
    value = "All stop",
    calcValueFunc = calcValueModuleDefrostRunning,
  },
  ModuleOnlineStatus = {
    pc_repeatTimes = 8,
    bindToProperty = "Module Online",
    outputName = "Module Online",
    dataType = "list",
    valueList = list_OnOff,
    value = list_OnOff[0],
    readOnly = true,
    landmarkEvent = {"Module Online","Module Offline"},
    landmarkCondition = function(info, name, newValue) return newValue == 1 end,
    calcValueFunc = calcValue1Reg,
  },
  ChillerSystemType = {
    bindToProperty = "System Type",
    outputName = "System Type",
    dataType = "list",
    valueList = {["Only Cool"] = 0, ["Heat"]=1},
    value = "Only Cool",
    readOnly = true,
    calcValueFunc = calcValue1Reg,
  },
  ChillerCommWithRemoter = {
    bindToProperty = "Communicate With Wired Controller",
    outputName = "Communicate With Wired Controller",
    dataType = "list",
    valueList = {["ERROR"] = 0, ["OK"]=1},
    readOnly = true,
    calcValueFunc = calcValue1Reg,
  },
  ViewModule = {
    bindToProperty = "Select A Module",
    dataType = "int",
    dataRange = {1,8},
    value=1,
    calcValueFunc = calcValue1Reg,
    onPropertyValueUpdated = showValueToUI,
  },
  ModuleFaultCode = {
    pc_repeatTimes = 8,
    bindToProperty = "Module Fault Code",
    outputName = "Module Fault Code",
    dataType = "string",
    readOnly = true,
    landmarkEvent = {"Module Malfunction","Module Operational"},
    landmarkCondition = function(info, name, newValue) return newValue ~= "No Alarm" end,
    value="No Alarm",
    calcValueFunc = calcValueModuleFaultCode,
  },
  ModuleEvnTemperature = {
    pc_repeatTimes = 8,
    bindToProperty = "Module Env Temperature",
    outputName = "Module Environment Temperature",
    dataType = "float",
    readOnly = true,
    calcValueFunc = calcValue1Reg,
  },
  ModuleWaterInletTemperature = {
    pc_repeatTimes = 8,
    bindToProperty = "Module Inlet Temperature",
    outputName = "Module Inlet Water Temperature",
    dataType = "float",
    readOnly = true,
    calcValueFunc = calcValue1Reg,
  },
  ModuleWaterOutletTemperature = {
    pc_repeatTimes = 8,
    bindToProperty = "Module Outlet Temperature",
    outputName = "Module Outlet Water Temperature",
    dataType = "float",
    readOnly = true,
    calcValueFunc = calcValue1Reg,
  },
  ModuleFinTemperature = {
    pc_repeatTimes = 8,
    bindToProperty = "Module Fin Temperature",
    outputName = "Module Fin Temperature",
    dataType = "string",
    readOnly = true,
    calcValueFunc = calcValueUnitsTemperature,
  },
  ModuleExhaustTemperature = {
    pc_repeatTimes = 8,
    bindToProperty = "Module Exhaust Temperature",
    outputName = "Module Exhause Air Temperature",
    dataType = "string",
    readOnly = true,
    calcValueFunc = calcValueUnitsTemperature,
  },
  ModuleInputVoltage = {
    pc_repeatTimes = 8,
    bindToProperty = "Module Input Voltage",
    outputName = "Module Input Voltage",
    dataType = "float",
    readOnly = true,
    calcValueFunc = calcValue1Reg,
  },
  ModuleCompressorCurrent = {
    pc_repeatTimes = 8,
    bindToProperty = "Module Compressor Current",
    outputName = "Module Compressor Current",
    dataType = "string",
    readOnly = true,
    calcValueFunc = calcModuleCompressorCurrent,
  },
  ChillerWorkModeSetting = {
    bindToProperty = "Chiller Work Mode Setting",
    outputName = "Chiller Work Mode Setting",
    dataType = "list",
    valueList = {["Cool"]=1, ["Heat"]=2},
    value = "Cool",
    onPropertyValueUpdated = function(info, name, value)
      if not DriverInitialed then return end
      if (value == "Cool") then
        DriverLib.postMsg(cmdSetChillerRunningMode(1))
      else
        DriverLib.postMsg(cmdSetChillerRunningMode(2))
      end
    end,
    calcValueFunc = calcValue1Reg,
  },
  ChillerCoolTemperatureSetting = {
    bindToProperty = "Chiller Refrideration Temperature",
    outputName = "Chiller Refrideration Temperature",
    dataType = "float",
    value = 15,
    onPropertyValueUpdated = function(info, name, value)
      if not DriverInitialed then return end
      DriverLib.postMsg(cmdSetChillerCoolTemperature(value))
    end,
    calcValueFunc = calcValue1Reg,
  },
  ChillerHeatTemperatureSetting = {
    bindToProperty = "Chiller Heat Temperature",
    outputName = "Chiller Heat Temperature",
    dataType = "float",
    value = 40,
    onPropertyValueUpdated = function(info, name, value)
      if not DriverInitialed then return end
      DriverLib.postMsg(cmdSetChillerHeatTemperature(value))
    end,
    calcValueFunc = calcValue1Reg,
  },
  ["Not Used"] = {
    dataType = "string",
    calcValueFunc = calcValue1Reg,
  }
}

function calcModuleName(name, moduleNo)
  return string.gsub(name,"Module","Module"..moduleNo,1)
end
local function repeatDriverVar(repeatTime, name, info, newTbl)
  for moduleNum = 1, repeatTime do
    local newInfo = {}
    newInfo["moduleNo"] = moduleNum
    for k,v in pairs (info) do
      if (type(v)=="string") then
        newInfo[k] = calcModuleName(v, " "..moduleNum)
      elseif (type(v)=="table") then
        local newValueTable = {}
        for id,value in pairs(v) do
          if (type(value) == "string") then
            newValueTable[id] = calcModuleName(value, " "..moduleNum)
          else
            newValueTable[id] = value
          end
        end
        newInfo[k] = newValueTable
      else
        newInfo[k] = v
      end
    end
    newInfo.bindToProperty = nil
    newTbl[calcModuleName(name, moduleNum)] = newInfo
  end
end
local function prepareDriverVars()
  local newAddDriverVars = {}
  for name, info in pairs(Mine_driverVars) do
    if (info.pc_repeatTimes ~= nill) then
      repeatDriverVar(info.pc_repeatTimes, name, info, newAddDriverVars)
      info["changeEvent"] = nil
      info["changeEventType"] = nil
      info["landmarkEvent"] = nil
      info["outputName"] = nil
      info["landmarkCondition"] = nil
    end
  end
  for k,v in pairs(newAddDriverVars) do
    Mine_driverVars[k] = v
  end
  grableAllModuleSpecialPropName()
end
  

constants = {
  ADDR_COIL_UNIT_RUNNING_STATE = 10001,
  ADDR_COIL_UNIT_FREEZE_PROOFING_RUNNING_STATE = 10002,
  ADDR_COIL_UNIT_FAULT_STATE = 10003,
  ADDR_COIL_UNIT_MODE = 10004,
  ADDR_COIL_UNIT_RESERVED_1 = 10005,
  ADDR_COIL_UNIT_OIL_PREHEATING_STATE = 10006,
  ADDR_COIL_UNIT_AIRCOND_PUMP_STATE = 10007,
  ADDR_COIL_UNIT_BOOSTER_STATE = 10008,

  ADDR_COIL_MODULE_IO_FAULT = 10009,
  ADDR_COIL_MODULE_COMPRESSOR_STATE = 10017,
  ADDR_COIL_MODULE_DEFROSTING_STATE = 10065,

  ADDR_DISCRETE_MODULE_ONLINE_STATE = 20001,
  ADDR_DISCRETE_UNIT_TYPE =  20013,
  ADDR_DISCRETE_UNIT_REMOTE_CONTROL_STATE = 20015,
  ---  ADDR_DISCRETE_MODULE_FAULT_STATE = 20017, start of module fault state code
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_STREAM = 20017,
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_PUMP = 20018,
  ADDR_DISCRETE_MODULE_FAULT_OF_POWER_LACK_PHASE = 20019,
  ADDR_DISCRETE_MODULE_FAULT_OF_POWER_ANTI_PHASE = 20020,
  ADDR_DISCRETE_MODULE_FAULT_OF_POWER_HIGH_VOLTAGE = 20021,
  ADDR_DISCRETE_MODULE_FAULT_OF_POWER_LOW_VOLRAGE = 20022,
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_OUTLET_LOW_TEMPERATURE = 20023,
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_OUTLET_HIGH_TEMPERATURE = 20024,
  ADDR_DISCRETE_MODULE_FAULT_OF_ENVIRONMENT_TEMPERATURE_SENSOR = 20025,
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_INLET_TEMPERATURE_SENDOR = 20026,
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_OUTLET_TEMPERATURE_SENSOR = 20027,
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_TEMPERATURE_DIFFERENTIAL_ALERT = 20028,
  ADDR_DISCRETE_MODULE_FAULT_OF_BLOWER_FAULT = 20030,
  ADDR_DISCRETE_MODULE_FAULT_OF_FIN_TEMPERATURE_SENSOR = 20033,
  ADDR_DISCRETE_MODULE_FAULT_OF_EXHAUST_TEMPERATURE_SENSOR = 20034,
  ADDR_DISCRETE_MODULE_FAULT_OF_LOW_PRESSURE = 20035,
  ADDR_DISCRETE_MODULE_FAULT_OF_HIGH_PRESSURE = 20036,
  ADDR_DISCRETE_MODULE_FAULT_OF_COMPRESSOR_OVER_CURRENT = 20037,
  ADDR_DISCRETE_MODULE_FAULT_OF_COMPRESSOR_LOW_CURRENT = 20038,
  ADDR_DISCRETE_MODULE_FAULT_OF_COMPRESSOR_EXHAUST_HIGH_TEMPERATURE = 20039,
  ADDR_DISCRETE_MODULE_FAULT_OF_4WAY_VALVE_FAULT = 20040,
  --- end of module fault state code
  ADDR_INPUTREG_MODULE_ENVIRONMENT_TEMPERATURE = 30001,
  ADDR_INPUTREG_MODULE_WATER_INLET = 30002,
  ADDR_INPUTREG_MODULE_WATER_OUTLET = 30003,
  ADDR_INPUTREG_MODULE_FIN_TEMPERATURE = 30004,
  ADDR_INPUTREG_MODULE_EXHAUST_AIR_TEMPERATURE = 30010,
  ADDR_INPUTREG_MODULE_INPUT_VOLTAGE = 30016,
  ADDR_INPUTREG_MODULE_COMPRESSOR_CURRENT = 30017,

  ADDR_HOLDINGREG_UNIT_RUNNING_MODE = 40001,
  ADDR_HOLDINGREG_UNIT_REFRIGERATION_TEMPERATURE = 40002,
  ADDR_HOLDINGREG_UNIT_HEATING_TEMPERATURE = 40003,

  ERROR_NO_ERROR = "SUCCESS",
  ERROR_INVALID_MODULE_NUMBER = "INVALID MODULE NO",
  ERROR_INVALID_DEVICE_NUMBER = "INVALID DEVICE NO",
  ERROR_INVALID_DATA_NUMBER = "INVALID DATA NUMBER",
  ERROR_NO_RESPONSE = "NO RESPONSE",
  ERROR_CRC_ERROR = "CRC ERROR",
  ERROR_WRONG_FUNCTION_CODE = "WRONG FUNCTION CODE",
  ERROR_WRONG_RESPONSE_CODE = "WRONG RESPONSE CODE",
  ERROR_HALF_RESPONSE = "HALF_BACKED RESPONSE",
  ERROR_SET_FAILED = "FAILED TO SET VALUE"

}

local registeVarName = {
  ADDR_COIL_UNIT_RUNNING_STATE = {"Chiller Start/Stop State","ChillerRunningState","??????"},
  ADDR_COIL_UNIT_FREEZE_PROOFING_RUNNING_STATE = {"Chiller anti-freezing","ChillerAntifreezingState","??????"},
  ADDR_COIL_UNIT_FAULT_STATE = {"Chiller Fault","ChillerFaultState","??????"},
  ADDR_COIL_UNIT_MODE = {"Current Running Mode","ChillerWorkingMode","??????"},
  ADDR_COIL_UNIT_RESERVED_1 = {"Reserved", "Not Used","??"},
  ADDR_COIL_UNIT_OIL_PREHEATING_STATE = {"Oil pre-heating","ChillerOilPreheatingState","???????"},
  ADDR_COIL_UNIT_AIRCOND_PUMP_STATE = {"AC Water Pump","ChillerWaterPumpState","??????"},
  ADDR_COIL_UNIT_BOOSTER_STATE = {"Auxiliary Heating","ChillerAuxiliaryHeatingState","???????"},

  ADDR_COIL_MODULE_IO_FAULT = {"I/O Board Fault","ModuleIOBoardOutput","I/O?????"},
  ADDR_COIL_MODULE_COMPRESSOR_STATE = {"Compressor State","ModuleCompressorState","?????"},
  ADDR_COIL_MODULE_DEFROSTING_STATE = {"Defrost Running state","ModuleDefrostRunning","??????"},

  ADDR_DISCRETE_MODULE_ONLINE_STATE = {"Online","ModuleOnlineStatus","????"},
  ADDR_DISCRETE_UNIT_TYPE =  {"System Type","ChillerSystemType","????(??/??)"},
  ADDR_DISCRETE_UNIT_REMOTE_CONTROL_STATE = {"Communicate with wired remoter","ChillerCommWithRemoter","??????"},
  ---  ADDR_DISCRETE_MODULE_FAULT_STATE {= 20017, start of module fault state "code"},
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_STREAM = {"Water Fault","ModuleFaultCode","????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_PUMP = {"Pump Fault","ModuleFaultCode","????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_POWER_LACK_PHASE = {"Power lack-phase fault","ModuleFaultCode", "??????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_POWER_ANTI_PHASE = {"Powe anti-phase fault","ModuleFaultCode","??????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_POWER_HIGH_VOLTAGE = {"Power high-voltage","ModuleFaultCode","????????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_POWER_LOW_VOLRAGE = {"Power low-voltage","ModuleFaultCode","????????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_OUTLET_LOW_TEMPERATURE = {"Water outlet low-temperature","ModuleFaultCode","??????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_OUTLET_HIGH_TEMPERATURE = {"Water outlet high-temperature","ModuleFaultCode","??????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_ENVIRONMENT_TEMPERATURE_SENSOR = {"Environment Temperature Sensor","ModuleFaultCode","???????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_INLET_TEMPERATURE_SENDOR = {"Water inlet temperature sensor","ModuleFaultCode","???????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_OUTLET_TEMPERATURE_SENSOR = {"Water outlet temperature sensor","ModuleFaultCode","???????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_WATER_TEMPERATURE_DIFFERENTIAL_ALERT = {"Water in/out temperture diff alarm","ModuleFaultCode","?/??????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_BLOWER_FAULT = {"Blower fault","ModuleFaultCode","????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_FIN_TEMPERATURE_SENSOR = {"Fin Temperature Sensor","ModuleFaultCode","???????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_EXHAUST_TEMPERATURE_SENSOR = {"Exhaust Air Temperature Sensor","ModuleFaultCode","???????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_LOW_PRESSURE = {"Low Pressure","ModuleFaultCode","????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_HIGH_PRESSURE = {"High Pressure","ModuleFaultCode","????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_COMPRESSOR_OVER_CURRENT = {"Compressor Over Current","ModuleFaultCode","?????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_COMPRESSOR_LOW_CURRENT = {"Compressor Low Current","ModuleFaultCode","???????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_COMPRESSOR_EXHAUST_HIGH_TEMPERATURE = {"Compressor exhaust high temperature","ModuleFaultCode","?????????"},
  ADDR_DISCRETE_MODULE_FAULT_OF_4WAY_VALVE_FAULT = {"4Way valve fault","ModuleFaultCode","?????"},
  --- end of module fault state "code",
  ADDR_INPUTREG_MODULE_ENVIRONMENT_TEMPERATURE = {"Environment TEmperature","ModuleEvnTemperature","??????"},
  ADDR_INPUTREG_MODULE_WATER_INLET = {"Water Inlet Temperature","ModuleWaterInletTemperature","??????"},
  ADDR_INPUTREG_MODULE_WATER_OUTLET = {"Water Inlet Temperature","ModuleWaterOutletTemperature","??????"},
  ADDR_INPUTREG_MODULE_FIN_TEMPERATURE = {"Fin Temperature","ModuleFinTemperature","????"},
  ADDR_INPUTREG_MODULE_EXHAUST_AIR_TEMPERATURE = {"Exhaust Air Temperature","ModuleExhaustTemperature","????"},
  ADDR_INPUTREG_MODULE_INPUT_VOLTAGE = {"Input Voltage","ModuleInputVoltage","??????"},
  ADDR_INPUTREG_MODULE_COMPRESSOR_CURRENT = {"Compressor Current","ModuleCompressorCurrent","?????"},

  ADDR_HOLDINGREG_UNIT_RUNNING_MODE = {"Control Running Mode","ChillerWorkModeSetting","??????"},
  ADDR_HOLDINGREG_UNIT_REFRIGERATION_TEMPERATURE = {"Control refrigeration temperature","ChillerCoolTemperatureSetting","???????"},
  ADDR_HOLDINGREG_UNIT_HEATING_TEMPERATURE = {"Control Heating tempreture","ChillerHeatTemperatureSetting","???????"},
}
-- this is the table used to lookup which reg-info should be used for an address

-----------------------------------------------------
-- address calculator returned "address, error code"
function unitAddressCalculator(regInfo, moduleNo, deviceNo)
  return regInfo.address, false
end

function moduleDeviceAddressCalculator(regInfo, moduleNo, deviceNo)
  if (moduleNo > regInfo.maxModuleNum) then
    return 0, constants.ERROR_INVALID_MODULE_NUMBER
  end

  if (deviceNo > regInfo.maxDeviceNum) then
    return 0, constants.ERROR_INVALID_DEVICE_NUMBER
  end

  return regInfo.address + (moduleNo-1) * regInfo.moduleAddressSize + deviceNo - 1
end

function faultCodeAddressCalculator(regInfo, moduleNo, deviceNo)
  if (moduleNo > regInfo.maxModuleNum) then
    return 0, constants.ERROR_INVALID_MODULE_NUMBER
  end

  if (deviceNo > regInfo.maxDeviceNum) then
    return 0, constants.ERROR_INVALID_DEVICE_NUMBER
  end

  return regInfo.address + (moduleNo-1) * regInfo.moduleAddressSize + (deviceNo - 1) * 8
end

function directValueCalculator(regInfo, data)
  return data
end

function temperatureToRegisterValue(regInfo, data)
  return (data + 40) * 10
end
function temperatureFromRegisterValue(regInfo, data)
  return data/10.0 - 40
end
function eleCurrentToRegisterValue(regInfo, data)
  return data * 10
end
function eleCurrentFromRegisterValue(regInfo, data)
  return data/10.0
end

local regInfos = {
  COIL_UNIT_RUNNING_STATE = {
    address = constants.ADDR_COIL_UNIT_RUNNING_STATE,
    maxModuleNum = 1,   maxDeviceNum = 1,  moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  COIL_UNIT_FREEZE_PROOFING_RUNNING_STATE = {
    address = constants.ADDR_COIL_UNIT_FREEZE_PROOFING_RUNNING_STATE,
    maxModuleNum = 1,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  COIL_UNIT_FAULT_STATE = {
    address = constants.ADDR_COIL_UNIT_FAULT_STATE,
    maxModuleNum = 1,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  COIL_UNIT_MODE = {
    address = constants.ADDR_COIL_UNIT_MODE,
    maxModuleNum = 1,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  COIL_UNIT_RESERVED_1 = {
    address = constants.ADDR_COIL_UNIT_RESERVED_1,
    maxModuleNum = 1,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  COIL_UNIT_OIL_PREHEATING_STATE = {
    address = constants.ADDR_COIL_UNIT_OIL_PREHEATING_STATE,
    maxModuleNum = 1,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  COIL_UNIT_AIRCOND_PUMP_STATE = {
    address = constants.ADDR_COIL_UNIT_AIRCOND_PUMP_STATE,
    maxModuleNum = 1,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  COIL_UNIT_BOOSTER_STATE = {
    address = constants.ADDR_COIL_UNIT_BOOSTER_STATE,
    maxModuleNum = 1,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },

  COIL_MODULE_IO_FAULT = {
    address = constants.ADDR_COIL_MODULE_IO_FAULT,
    maxModuleNum = 8,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = moduleDeviceAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  COIL_MODULE_COMPRESSOR_STATE = {
    address = constants.ADDR_COIL_MODULE_COMPRESSOR_STATE,
    maxModuleNum = 8,   maxDeviceNum = 6,   moduleAddressSize = 6,
    addressCalculator = moduleDeviceAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  COIL_MODULE_DEFROSTING_STATE = {
    address = constants.ADDR_COIL_MODULE_DEFROSTING_STATE,
    maxModuleNum = 8,   maxDeviceNum = 6,   moduleAddressSize = 6,
    addressCalculator = moduleDeviceAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },

  DISCRETE_MODULE_ONLINE_STATE = {
    address = constants.ADDR_DISCRETE_MODULE_ONLINE_STATE,
    maxModuleNum = 8,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = moduleDeviceAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_UNIT_TYPE = {
    address = constants.ADDR_DISCRETE_UNIT_TYPE,
    maxModuleNum = 1,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_UNIT_REMOTE_CONTROL_STATE = {
    address = constants.ADDR_DISCRETE_UNIT_REMOTE_CONTROL_STATE,
    maxModuleNum = 1,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  --------------------------module fault---------------------------
  DISCRETE_MODULE_FAULT_OF_WATER_STREAM = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_WATER_STREAM,
    maxModuleNum = 8, maxDeviceNum = 1, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_WATER_PUMP = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_WATER_PUMP,
    maxModuleNum = 8, maxDeviceNum = 1, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_POWER_LACK_PHASE = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_POWER_LACK_PHASE,
    maxModuleNum = 8, maxDeviceNum = 1, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_POWER_ANTI_PHASE = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_POWER_ANTI_PHASE,
    maxModuleNum = 8, maxDeviceNum = 1, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_POWER_HIGH_VOLTAGE = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_POWER_HIGH_VOLTAGE,
    maxModuleNum = 8, maxDeviceNum = 1, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_POWER_LOW_VOLRAGE = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_POWER_LOW_VOLRAGE,
    maxModuleNum = 8, maxDeviceNum = 1, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_WATER_OUTLET_LOW_TEMPERATURE = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_WATER_OUTLET_LOW_TEMPERATURE,
    maxModuleNum = 8, maxDeviceNum = 1, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_WATER_OUTLET_HIGH_TEMPERATURE = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_WATER_OUTLET_HIGH_TEMPERATURE,
    maxModuleNum = 8, maxDeviceNum = 1, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_ENVIRONMENT_TEMPERATURE_SENSOR = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_ENVIRONMENT_TEMPERATURE_SENSOR,
    maxModuleNum = 8, maxDeviceNum = 1, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_WATER_INLET_TEMPERATURE_SENDOR = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_WATER_INLET_TEMPERATURE_SENDOR,
    maxModuleNum = 8, maxDeviceNum = 1, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_WATER_OUTLET_TEMPERATURE_SENSOR = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_WATER_OUTLET_TEMPERATURE_SENSOR,
    maxModuleNum = 8, maxDeviceNum = 1, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_WATER_TEMPERATURE_DIFFERENTIAL_ALERT = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_WATER_TEMPERATURE_DIFFERENTIAL_ALERT,
    maxModuleNum = 8, maxDeviceNum = 1, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_BLOWER_FAULT = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_BLOWER_FAULT,
    maxModuleNum = 8, maxDeviceNum = 3, moduleAddressSize = 64,
    addressCalculator = moduleDeviceAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_FIN_TEMPERATURE_SENSOR = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_FIN_TEMPERATURE_SENSOR,
    maxModuleNum = 8, maxDeviceNum = 6, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_EXHAUST_TEMPERATURE_SENSOR = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_EXHAUST_TEMPERATURE_SENSOR,
    maxModuleNum = 8, maxDeviceNum = 6, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_LOW_PRESSURE = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_LOW_PRESSURE,
    maxModuleNum = 8, maxDeviceNum = 6, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_HIGH_PRESSURE = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_HIGH_PRESSURE,
    maxModuleNum = 8, maxDeviceNum = 6, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_COMPRESSOR_OVER_CURRENT = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_COMPRESSOR_OVER_CURRENT,
    maxModuleNum = 8, maxDeviceNum = 6, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_COMPRESSOR_LOW_CURRENT = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_COMPRESSOR_LOW_CURRENT,
    maxModuleNum = 8, maxDeviceNum = 6, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_COMPRESSOR_EXHAUST_HIGH_TEMPERATURE = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_COMPRESSOR_EXHAUST_HIGH_TEMPERATURE,
    maxModuleNum = 8, maxDeviceNum = 6, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  DISCRETE_MODULE_FAULT_OF_4WAY_VALVE_FAULT = {
    address = constants.ADDR_DISCRETE_MODULE_FAULT_OF_4WAY_VALVE_FAULT,
    maxModuleNum = 8, maxDeviceNum = 6, moduleAddressSize = 64,
    addressCalculator = faultCodeAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  -----------------------------------------------------

  INPUTREG_MODULE_ENVIRONMENT_TEMPERATURE = {
    address = constants.ADDR_INPUTREG_MODULE_ENVIRONMENT_TEMPERATURE,
    maxModuleNum = 8,   maxDeviceNum = 1,   moduleAddressSize = 22,
    addressCalculator = moduleDeviceAddressCalculator,
    toRegisterValue = temperatureToRegisterValue,
    fromRegisterValue = temperatureFromRegisterValue
  },
  INPUTREG_MODULE_WATER_INLET = {
    address = constants.ADDR_INPUTREG_MODULE_WATER_INLET,
    maxModuleNum = 8,   maxDeviceNum = 1,   moduleAddressSize = 22,
    addressCalculator = moduleDeviceAddressCalculator,
    toRegisterValue = temperatureToRegisterValue,
    fromRegisterValue = temperatureFromRegisterValue
  },
  INPUTREG_MODULE_WATER_OUTLET = {
    address = constants.ADDR_INPUTREG_MODULE_WATER_OUTLET,
    maxModuleNum = 8,   maxDeviceNum = 1,   moduleAddressSize = 22,
    addressCalculator = moduleDeviceAddressCalculator,
    toRegisterValue = temperatureToRegisterValue,
    fromRegisterValue = temperatureFromRegisterValue
  },
  INPUTREG_MODULE_FIN_TEMPERATURE = {
    address = constants.ADDR_INPUTREG_MODULE_FIN_TEMPERATURE,
    maxModuleNum = 8,   maxDeviceNum = 6,   moduleAddressSize = 22,
    addressCalculator = moduleDeviceAddressCalculator,
    toRegisterValue = temperatureToRegisterValue,
    fromRegisterValue = temperatureFromRegisterValue
  },
  INPUTREG_MODULE_EXHAUST_AIR_TEMPERATURE = {
    address = constants.ADDR_INPUTREG_MODULE_EXHAUST_AIR_TEMPERATURE,
    maxModuleNum = 8,   maxDeviceNum = 6,   moduleAddressSize = 22,
    addressCalculator = moduleDeviceAddressCalculator,
    toRegisterValue = temperatureToRegisterValue,
    fromRegisterValue = temperatureFromRegisterValue
  },
  INPUTREG_MODULE_INPUT_VOLTAGE = {
    address = constants.ADDR_INPUTREG_MODULE_INPUT_VOLTAGE,
    maxModuleNum = 8,   maxDeviceNum = 1,   moduleAddressSize = 22,
    addressCalculator = moduleDeviceAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  INPUTREG_MODULE_COMPRESSOR_CURRENT = {
    address = constants.ADDR_INPUTREG_MODULE_COMPRESSOR_CURRENT,
    maxModuleNum = 8,   maxDeviceNum = 6,   moduleAddressSize = 22,
    addressCalculator = moduleDeviceAddressCalculator,
    toRegisterValue = eleCurrentToRegisterValue,
    fromRegisterValue = eleCurrentFromRegisterValue
  },

  HOLDINGREG_UNIT_RUNNING_MODE = {
    address = constants.ADDR_HOLDINGREG_UNIT_RUNNING_MODE,
    maxModuleNum = 1,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = directValueCalculator,
    fromRegisterValue = directValueCalculator
  },
  HOLDINGREG_UNIT_REFRIGERATION_TEMPERATURE = {
    address = constants.ADDR_HOLDINGREG_UNIT_REFRIGERATION_TEMPERATURE,
    maxModuleNum = 1,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = temperatureToRegisterValue,
    fromRegisterValue = temperatureFromRegisterValue
  },
  HOLDINGREG_UNIT_HEATING_TEMPERATURE = {
    address = constants.ADDR_HOLDINGREG_UNIT_HEATING_TEMPERATURE,
    maxModuleNum = 1,   maxDeviceNum = 1,   moduleAddressSize = 1,
    addressCalculator = unitAddressCalculator,
    toRegisterValue = temperatureToRegisterValue,
    fromRegisterValue = temperatureFromRegisterValue
  }
}

--local tempTbl = {}
--local nameTbl = {}
--for k,v in pairs(constants) do
--  if (type(v) == "number") then
--    table.insert(tempTbl,v)
--    table.insert(nameTbl,v,string.sub(k,6))
--  end
--end
--
--table.sort(tempTbl)
-- TODO: add any intializatin code
function initLookupTable()
  prepareDriverVars()
  
  for k,v in pairs(regInfos) do
    local regInfo = v
    for m = 1, regInfo.maxModuleNum do
      for d = 1, regInfo.maxDeviceNum do
        local address = regInfo:addressCalculator(m,d)
        local regVarName = registeVarName["ADDR_"..k][1]
        if (regInfo.maxModuleNum > 1) then
          if (regInfo.maxDeviceNum > 1) then
            regVarName = d .. "#" .. regVarName --.. "-Module" .. m
          else
            regVarName = regVarName --.. "-Module" .. m
          end
        end
        local driverVarName = registeVarName["ADDR_"..k][2]
        local drvVarInfo = Mine_driverVars[driverVarName]
        if (drvVarInfo ~= nil and drvVarInfo.pc_repeatTimes ~= nil) then
          driverVarName = calcModuleName(driverVarName, m)
        end
        local data = {
          regName = k,
          varName = regVarName,
          info = regInfo,
          moduleNo = m,
          deviceNo = d,
          drvVarName = driverVarName,
        }
        if (addressLookupTable[address]) then
          print ("found conflict")
          PrintTable(data)
          print ("  with")
          PrintTable(addressLookupTable[address])
          return
        end
        table.insert(addressLookupTable,address, data)
        if (Mine_driverVars[driverVarName] ==  nil) then
          print("Not found " .. driverVarName)
        end
        if (Mine_driverVars[driverVarName]["calcValueFunc"] ==  nil) then
          print("No value calculator " .. driverVarName)
        end
        if (Mine_driverVars[driverVarName]["regAddrs"] == nil) then
          Mine_driverVars[driverVarName]["regAddrs"] = {}
        end
        table.insert(Mine_driverVars[driverVarName]["regAddrs"], address)
      end
    end
  end
  
  for k,v in pairs(Mine_driverVars) do
--    printTable(v)
--    table.sort(v.regAddrs)
    if v.regAddrs then
      table.sort(v.regAddrs)
    end
  end
end

function printOutAddressTable()
  local keyTbl = {}
  for k,v in pairs(addressLookupTable) do
    table.insert(keyTbl,k)
  end
  table.sort(keyTbl)

  for i,address in pairs(keyTbl) do
    local data = addressLookupTable[address]
    local str = "" .. address .. " is " .. data.regName .. "(" .. data.varName .. ")"
    local regInfo = data.info
    if (data.drvVarName ~= nil) then
      str = str .. " ---> " .. data.drvVarName
    end
    print(str)
  end
end

function commonBitsResponseHandler(idBinding, strData, tParams, functionCode)
  local result = verifyResponse(functionCode, strData)
  if (result.errorState ~= constants.ERROR_NO_ERROR) then
    return result
  end
  local regInfo = addressLookupTable[tParams.regAddr].info
  local returedRegNum = strData:byte(3,3)
  if (returedRegNum * 8) < tParams.regNum then
    tParams.regNum = returedRegNum * 8
  end
  local startAddr = regInfo.addressCalculator(regInfo, tParams.moduleNo or 1, tParams.deviceNo or 1)
  local offSet, bitPos = 4,0
  for i=0, tParams.regNum-1 do
    local regAddr = startAddr + i
    if (addressLookupTable[regAddr]) then
      local regInfo = addressLookupTable[regAddr].info
      local regValue = bit.band(1, bit.rshift(string.byte(strData, offSet, offSet), bitPos))
      local outValue = regInfo.fromRegisterValue(regInfo, regValue)
      result[regAddr] = outValue

      bitPos = bitPos + 1
      if (bitPos >= 8) then
        bitPos = 0
        offSet = offSet + 1
      end
    end
  end
  return result
end

function commonReadCommand(tParams, funCode)
  local regInfo = addressLookupTable[tParams.regAddr].info
  local regAddress, errMsg = regInfo.addressCalculator(regInfo, tParams.moduleNo or 1, tParams.deviceNo or 1)
  if (errMsg) then
    return nil, errMsg
  end
  if (addressLookupTable[regAddress] == nil) then
    return nil, "ERROR_WRONG_ADDRESS"
  end
  return string.format("%02X %02X %02X %02X %02X %02X", tParams.address, funCode,
    DriverLib.byte1(regAddress), DriverLib.byte0(regAddress),
    DriverLib.byte1(tParams.regNum), DriverLib.byte0(tParams.regNum))
end

function commonShortsResponseHandler(idBinding, strData, tParams, functionCode)
  local result = verifyResponse(functionCode, strData)
  if (result.errorState ~= constants.ERROR_NO_ERROR) then
    return result
  end
  local regInfo = addressLookupTable[tParams.regAddr].info
  local startAddr = regInfo.addressCalculator(regInfo, tParams.moduleNo or 1, tParams.deviceNo or 1)
  local offSet, bitPos = 4,0
  for i=0, tParams.regNum-1 do
    local regAddr = startAddr + i
    if (addressLookupTable[regAddr]) then
      local regInfo = addressLookupTable[regAddr].info
      local regValue = DriverLib.toShort(string.sub(strData,offSet,offSet+1))
      local outValue = regInfo.fromRegisterValue(regInfo, regValue)
      result[regAddr] = outValue
      offSet = offSet + 2
    end
  end
  return result
end

allRegValues = {}
function storeValues(newData)
  local changedDrvVars = {}
  for addr,value in pairs(newData) do
    if (type(addr) == "number") then
      allRegValues[addr] = value
      local regInfo = addressLookupTable[addr]
      changedDrvVars[regInfo.drvVarName] = {}
    end
  end
  return changedDrvVars
end

local verifyRules = {
  [1] = { [1] = true, minLength = 6 },
  [2] = { [2] = true, minLength = 6 },
  [3] = { [3] = true, minLength = 7 },
  [4] = { [4] = true, minLength = 7 },
  [5] = { [5] = true, minLength = 8 },
  [16] = { [16] = true, minLength = 8 },
}
function verifyResponse(reqFuncCode, strData)
  -- verify CRC
  local result = {errorState=constants.ERROR_NO_ERROR}
  if (not DriverLib.verifyCrc16(strData,#strData)) then
    result.errorState = constants.ERROR_CRC_ERROR
    return result
  end

  -- is this my supported function code?
  local verifyRule = verifyRules[reqFuncCode]
  if (not verifyRule) then
    result.errorState = constants.ERROR_WRONG_FUNCTION_CODE
    return result
  end

  local respFunCode = string.byte(strData,2,2)
  if (not verifyRule[respFunCode]) then
    result.errorState = constants.ERROR_WRONG_RESPONSE_CODE
    result.code = string.byte(strData,3,3)
    return result
  end

  if (#strData < verifyRule.minLength) then
    result.errorState = constants.ERROR_HALF_RESPONSE
    return result
  end

  return result
end
local cmdMaker = {
  commandCode = nil,
  commandParams = nil,
  cmdReadCoils = {
    functionCode = 1,
    command = commonReadCommand,
    responseHandler = commonBitsResponseHandler
  },
  cmdReadDiscreteInputs = {
    functionCode = 2,
    command = commonReadCommand,
    responseHandler = commonBitsResponseHandler
  },
  cmdReadHoldingRegisters = {
    functionCode = 3,
    command = commonReadCommand,
    responseHandler = commonShortsResponseHandler
  },
  cmdReadInputRegisters = {
    functionCode = 4,
    command = commonReadCommand,
    responseHandler = commonShortsResponseHandler
  },
  cmdWriteSingleCoil = {
    functionCode = 5,
    command = function(tParams, funCode)
      local regInfo = addressLookupTable[tParams.regAddr].info
      local regAddress, errMsg = regInfo.addressCalculator(regInfo, tParams.moduleNo or 1, tParams.deviceNo or 1)
      if (errMsg) then
        return nil, errMsg
      end
      local dataValue = regInfo.toRegisterValue(regInfo, tParams.value)
      return string.format("%02X %02X %02X %02X %02X %02X", tParams.address, funCode,
        DriverLib.byte1(regAddress), DriverLib.byte0(regAddress),
        DriverLib.byte1(dataValue), DriverLib.byte0(dataValue))
    end,
    responseHandler = function(idBinding, strData, tParams, funCode)
      local result = verifyResponse(funCode, strData)
      if (result.errorState ~= constants.ERROR_NO_ERROR) then
        return result
      end
      return result
    end
  },
  cmdWriteMultipleRegisters = {
    functionCode = 16,
    command = function(tParams, funCode)
      local regInfo = addressLookupTable[tParams.regAddr].info
      tParams.regNum = #(tParams.value)
      local regAddress, errMsg = regInfo.addressCalculator(regInfo, tParams.moduleNo or 1, tParams.deviceNo or 1)
      if (errMsg) then
        return nil, errMsg
      end
      local cmdStr = string.format("%02X %02X %02X %02X %02X %02X %02X", 
        tParams.address, funCode,
        DriverLib.byte1(regAddress), DriverLib.byte0(regAddress), 
        DriverLib.byte1(tParams.regNum), DriverLib.byte0(tParams.regNum),
        DriverLib.byte0(tParams.regNum * 2))
      for i=1,tParams.regNum do
        local value = tParams.value[i]
        local dataValue = value
        if (addressLookupTable[regAddress+i-1]) then
          local regInfo = addressLookupTable[regAddress+i-1].info
          dataValue = regInfo.toRegisterValue(regInfo, value)
        end
        cmdStr = cmdStr .. string.format(" %02X %02X", DriverLib.byte1(dataValue), DriverLib.byte0(dataValue))
      end
      return cmdStr
    end,
    responseHandler = function(idBinding, strData, tParams, funCode)
      local result = verifyResponse(funCode, strData)
      if (result.errorState ~= constants.ERROR_NO_ERROR) then
        return result
      end
      return result
    end
  },

}
-----------------------------------------------------------------------------------------
--initLookupTable()
--
--
--
--local address = 20034
--local data = addressLookupTable[address]
----printTable(data)
----print(data.info:addressCalculator(data.moduleNo, data.deviceNo))
----printTable(addressLookupTable)
--printOutAddressTable()


function sendOneCommand(code, tParams)
  local cmdInfo = cmdMaker[code]
  cmdMaker.commandCode = code
  cmdMaker.commandParams = tParams
  local cmdStr,errorMsg = cmdInfo.command(tParams, cmdInfo.functionCode)
  if (errorMsg ) then
    return errorMsg
  end
  local crcStr = tohex(cmdStr)
  SendCommand(crcStr .. DriverLib.crc16(crcStr))
end

function notifySendCoroutine()
  cmdMaker.commandCode = nil
  cmdMaker.commandParams = nil
  coroutine.resume(sendProcess, "from response process")
end
function handleCommandResponse(idBinding, strData)
  if (not cmdMaker.commandCode) then
    return
  end
  local cmdInfo = cmdMaker[cmdMaker.commandCode]
  local params = cmdMaker.commandParams
  cmdMaker.commandCode = nil
  cmdMaker.commandParams = nil
  local result = cmdInfo.responseHandler(idBinding, strData, params, cmdInfo.functionCode)

  if (result.errorState ~= constants.ERROR_NO_ERROR) then
    DriverLib.postMsg("has error ".. result.errorState .. " with code " .. result.code)
    notifySendCoroutine()
    return
  end
  
  -- debug
  result.errorState = nil
  for k,v in pairs(result) do
    if (Mine_driverVars[k] ~= nil) then
      PropertyHandlingSpecialist:updateProperty( k,v)
    end
  end
  local changedVars = storeValues(result)
--  printTable(changedVars)
--  printTable(allRegValues)
  --TODO add code to calculation the correct values of UI properties
  for name,v in pairs(changedVars) do
    local drvVarInfo = Mine_driverVars[name]
    if (drvVarInfo == nil) then
      print("Error: cannot found driver var " .. name)
    end
    changedVars[name] = drvVarInfo.calcValueFunc(drvVarInfo, name)
  end
--  printTable(changedVars)
  for name,val in pairs(changedVars) do
    PropertyHandlingSpecialist:updateProperty(name,val)
  end
  showValueToUI(nil, "Select Module", Properties["Select Module"])
  DriverLib.postMsg(result.errorMsg or "Received Data Processed")
  notifySendCoroutine()
end

function resetTaskQueue()
  local queueLen = #taskQueue
  if (queueLen <= 0) then return end
  for i=1,queueLen do
    table.remove(taskQueue)
  end
  cmdMaker.commandCode = nil
end
function pushTask(code, tParams)
  table.insert(taskQueue,{code=code, params=tParams})
  coroutine.resume(sendProcess, "from task")
end
function popTask()
  local theTask = taskQueue[1]
  local queueLen = #taskQueue
  if queueLen < 1 then return theTask end
  if queueLen == 1 then table.remove(taskQueue,1) return theTask end
  for i=1,queueLen-1 do
    taskQueue[i] = taskQueue[i+1]
  end
  table.remove(taskQueue)
  return theTask
end

function cmdWriteSingleCoil(tParams)
  resetTaskQueue()
  pushTask("cmdWriteSingleCoil", {regAddr=tParams[1], address=deviceAddress, value=tParams[2]})
  return constants.ERROR_NO_ERROR
end
function cmdQuerySystemStatus(tParams)
  resetTaskQueue()
  pushTask("cmdReadCoils", {regAddr=constants.ADDR_COIL_UNIT_RUNNING_STATE, address=deviceAddress, regNum=8})
  pushTask("cmdReadDiscreteInputs", {regAddr=constants.ADDR_DISCRETE_MODULE_ONLINE_STATE, address=deviceAddress, regNum=16})
  pushTask("cmdReadHoldingRegisters", {regAddr=constants.ADDR_HOLDINGREG_UNIT_RUNNING_MODE, address=deviceAddress, regNum=3})
  return constants.ERROR_NO_ERROR
end
function cmdQueryModuleStatus(tParams)
  resetTaskQueue()
  pushTask("cmdReadCoils", {regAddr=constants.ADDR_COIL_MODULE_IO_FAULT, address=deviceAddress, regNum=104})
  pushTask("cmdReadDiscreteInputs", {regAddr=constants.ADDR_DISCRETE_MODULE_FAULT_OF_WATER_STREAM, address=deviceAddress, regNum=64, moduleNo=tParams[1]})
  pushTask("cmdReadInputRegisters", {regAddr=constants.ADDR_INPUTREG_MODULE_ENVIRONMENT_TEMPERATURE, address=deviceAddress, regNum=22, moduleNo=tParams[1]})
  return constants.ERROR_NO_ERROR
end
function cmdSetChillerRunningMode(mode)
  resetTaskQueue()
  pushTask("cmdWriteMultipleRegisters", {regAddr=constants.ADDR_HOLDINGREG_UNIT_RUNNING_MODE, address=deviceAddress, value={mode}})
  return constants.ERROR_NO_ERROR
end
function cmdSetChillerCoolTemperature(value)
  resetTaskQueue()
  pushTask("cmdWriteMultipleRegisters", {regAddr=constants.ADDR_HOLDINGREG_UNIT_REFRIGERATION_TEMPERATURE, address=deviceAddress, value={value}})
  return constants.ERROR_NO_ERROR
end
function cmdSetChillerHeatTemperature(value)
  resetTaskQueue()
  pushTask("cmdWriteMultipleRegisters", {regAddr=constants.ADDR_HOLDINGREG_UNIT_HEATING_TEMPERATURE, address=deviceAddress, value={value}})
  return constants.ERROR_NO_ERROR
end
function queryAllStatus()
  resetTaskQueue()
  pushTask("cmdReadCoils", {regAddr=constants.ADDR_COIL_UNIT_RUNNING_STATE, address=deviceAddress, regNum=114})
  pushTask("cmdReadDiscreteInputs", {regAddr=constants.ADDR_DISCRETE_MODULE_ONLINE_STATE, address=deviceAddress, regNum=528})
  pushTask("cmdReadHoldingRegisters", {regAddr=constants.ADDR_HOLDINGREG_UNIT_RUNNING_MODE, address=deviceAddress, regNum=3})
  for moduleID=1,8 do
    pushTask("cmdReadInputRegisters", {regAddr=constants.ADDR_INPUTREG_MODULE_ENVIRONMENT_TEMPERATURE, address=deviceAddress, regNum=22, moduleNo=moduleID})
  end
  return constants.ERROR_NO_ERROR
end
function cmdShowAllValue()
  local addrSet = DriverLib.getSortedKeys(allRegValues)
  for i,addr in pairs(addrSet) do
    local value = allRegValues[addr]
    local regInfo = addressLookupTable[addr]
    if regInfo.info.maxModuleNum > 1 then
      print(string.format("[%d] Module %d %s = %s", addr, regInfo.moduleNo, regInfo.varName, tostring(value)))
    else
      print(string.format("[%d] %s = %s", addr, regInfo.varName, tostring(value)))
    end
  end
  return constants.ERROR_NO_ERROR
end
local CONST_COIL_0 = 0
local CONST_COIL_1 = 0xFF00
Mine_Actions = {
  ["startChiller"] = {
    callFunc = cmdWriteSingleCoil,
    params = { {value=constants.ADDR_COIL_UNIT_RUNNING_STATE}, {value=CONST_COIL_1}},
  },
  ["stopChiller"] = {
    callFunc = cmdWriteSingleCoil,
    params = { {value=constants.ADDR_COIL_UNIT_RUNNING_STATE}, {value=CONST_COIL_0}},
  },
  ["startAntiFreezing"] = {
    callFunc = cmdWriteSingleCoil,
    params = { {value=constants.ADDR_COIL_UNIT_FREEZE_PROOFING_RUNNING_STATE}, {value=CONST_COIL_1}},
  },
  ["stopAntiFreezing"] = {
    callFunc = cmdWriteSingleCoil,
    params = { {value=constants.ADDR_COIL_UNIT_FREEZE_PROOFING_RUNNING_STATE}, {value=CONST_COIL_0}},
  },
  ["forceSystemFault"] = {  
    callFunc = cmdWriteSingleCoil,
    params = { {value=constants.ADDR_COIL_UNIT_FAULT_STATE}, {value=CONST_COIL_1}},
  },  
  ["clearSystemFault"] = {  
    callFunc = cmdWriteSingleCoil,
    params = { {value=constants.ADDR_COIL_UNIT_FAULT_STATE}, {value=CONST_COIL_0}},
  }, 
  ["querySystemStatus"] = {  
    callFunc = cmdQuerySystemStatus,
    params = { {value=constants.ADDR_COIL_UNIT_RUNNING_STATE}, {value=114}},
  },
  ["queryModuleStatus"] = {  
    callFunc = cmdQueryModuleStatus,
    params = { 
      {propertyName="ViewModule"},
    },
  },
  ["showAllValue"] = {  
    callFunc = cmdShowAllValue,
    params = {{propertyName="ViewModule"}},
  },
}
function sendCoRouting()
  while true do
    if (cmdMaker.commandCode ~= nil) then
      local msg  = coroutine.yield()
    else
      local task = popTask()
      if (task ~= nil) then
        sendOneCommand(task.code, task.params)
      end
      local msg = coroutine.yield()
    end
  end
end

function EX_CMD.StartStopChiller(tParams)
  if tParams.state == nil then return end
  if (tParams.state == "Start") then
    cmdWriteSingleCoil({constants.ADDR_COIL_UNIT_RUNNING_STATE, CONST_COIL_1})
  else
    cmdWriteSingleCoil({constants.ADDR_COIL_UNIT_RUNNING_STATE, CONST_COIL_0})
  end
end
function EX_CMD.StartStopAntiFreezing(tParams)
  if tParams.state == nil then return end
  if (tParams.state == "Start") then
    cmdWriteSingleCoil({constants.ADDR_COIL_UNIT_FREEZE_PROOFING_RUNNING_STATE, CONST_COIL_1})
  else
    cmdWriteSingleCoil({constants.ADDR_COIL_UNIT_FREEZE_PROOFING_RUNNING_STATE, CONST_COIL_0})
  end
end
function EX_CMD.SetChillerFault(tParams)
  if tParams.state == nil then return end
  if (tParams.state == "Alarm") then
    cmdWriteSingleCoil({constants.ADDR_COIL_UNIT_FAULT_STATE, CONST_COIL_1})
  else
    cmdWriteSingleCoil({constants.ADDR_COIL_UNIT_FAULT_STATE, CONST_COIL_0})
  end
end
function EX_CMD.SetChillerRunningMode(tParams)
  if tParams.state == nil then return end
  if (tParams.state == "Cool") then
    cmdSetChillerRunningMode(1)
  else
    cmdSetChillerRunningMode(2)
  end
end

function EX_CMD.SetCoolHeatTemperature(tParams)
  local cool,heat = tonumber(tParams.cool), tonumber(tParams.heat)
  if (cool == nil) or (heat == nil) then return end
  if (type(cool) ~= "number") or (type(heat) ~= "number") then return end
  if (cool < 10 or cool > 25) then return end
  if (heat < 25 or heat > 55) then return end
  --resetTaskQueue()
  pushTask("cmdWriteMultipleRegisters", {regAddr=constants.ADDR_HOLDINGREG_UNIT_REFRIGERATION_TEMPERATURE, address=deviceAddress, value={cool,heat}})
  return constants.ERROR_NO_ERROR
end
initLookupTable()
sendProcess = coroutine.create(sendCoRouting)
coroutine.resume(sendProcess, "star")
propertyNameMap = {
}
PropertyHandlingSpecialist:accept(propertyNameMap, Mine_driverVars)
ActionHandlingSpecialist:accept(Mine_Actions)

function EX_CMD.WhoAmI(tParams)
  local resp = {
	  deviceId = C4:GetDeviceID(),
	  profile = "AirCooledChiller"
  }
  C4:SendToDevice(tParams.deviceId, "UpdateProfile", resp)
end

]]></script>
        <actions>
            <action>
                <name>Show All Register Values</name>
                <command>showAllValue</command>
            </action>
            <action>
                <name>Clear System Fault</name>
                <command>clearSystemFault</command>
            </action>
            <action>
                <name>Force System Fault</name>
                <command>forceSystemFault</command>
            </action>
            <action>
                <name>Stop Anti-Freezing</name>
                <command>stopAntiFreezing</command>
            </action>
            <action>
                <name>Start Anti-Freezing</name>
                <command>startAntiFreezing</command>
            </action>
            <action>
                <name>Stop Chiller</name>
                <command>stopChiller</command>
            </action>
            <action>
                <name>Start Chiller</name>
                <command>startChiller</command>
            </action>
            <action>
                <name>Query Module Status</name>
                <command>queryModuleStatus</command>
            </action>
            <action>
                <name>Query System Status</name>
                <command>querySystemStatus</command>
            </action>
            <action>
                <name>Show Status</name>
                <command>ShowStatus</command>
            </action>
        </actions>
        <commands>
            <command>
                <name>StartStopChiller</name>
                <description>Start Stop Chiller</description>
                <params>
                    <param>
                        <name>state</name>
                        <type>LIST</type>
                        <readonly>False</readonly>
                        <default />
                        <items>
                            <item>Start</item>
                            <item>Stop</item>
                        </items>
                    </param>
                </params>
            </command>
            <command>
                <name>StartStopAntiFreezing</name>
                <description>Start Stop anti-Freezing</description>
                <params>
                    <param>
                        <name>state</name>
                        <type>LIST</type>
                        <readonly>False</readonly>
                        <default />
                        <items>
                            <item>Start</item>
                            <item>Stop</item>
                        </items>
                    </param>
                </params>
            </command>
            <command>
                <name>SetChillerFault</name>
                <description>Set or clear chiller fault</description>
                <params>
                    <param>
                        <name>state</name>
                        <type>LIST</type>
                        <readonly>False</readonly>
                        <default />
                        <items>
                            <item>Alarm</item>
                            <item>Clear Alarm</item>
                        </items>
                    </param>
                </params>
            </command>
            <command>
                <name>SetCoolHeatTemperature</name>
                <description>SetCoolHeatTemperature</description>
				<params>
				  <param>
					<name>cool</name>
					<type>RANGED_FLOAT</type>
					<minimum>10</minimum>
					<maximum>25</maximum>
				  </param>
				  <param>
					<name>heat</name>
					<type>RANGED_FLOAT</type>
					<minimum>25</minimum>
					<maximum>55</maximum>
				  </param>				</params>
            </command>
            <command>
                <name>SetChillerRunningMode</name>
                <description>Set Chille rRunning Mode</description>
                <params>
                    <param>
                        <name>state</name>
                        <type>LIST</type>
                        <readonly>False</readonly>
                        <default />
                        <items>
                            <item>Cool</item>
                            <item>Heat</item>
                        </items>
                    </param>
                </params>
            </command>
        </commands>
        <properties>
            <property>
                <name>Debug Level</name>
                <type>LIST</type>
                <readonly>false</readonly>
                <default>2 - Warning</default>
                <items>
                    <item>0 - Alert</item>
                    <item>1 - Error</item>
                    <item>2 - Warning</item>
                    <item>3 - Info</item>
                    <item>4 - Trace</item>
                    <item>5 - Debug</item>
                </items>
            </property>
            <property>
                <name>Debug Mode</name>
                <type>LIST</type>
                <readonly>false</readonly>
                <default>Off</default>
                <items>
                    <item>Off</item>
                    <item>Print</item>
                    <item>Log</item>
                    <item>Print and Log</item>
                </items>
            </property>
            <property>
                <name>Address</name>
                <type>RANGED_INTEGER</type>
                <readonly>false</readonly>
                <default>10</default>
                <minimum>1</minimum>
                <maximum>255</maximum>
            </property>
            <property>
                <name>Use Serial Agent</name>
                <type>LIST</type>
                <readonly>false</readonly>
                <default>Yes</default>
                <items>
                    <item>Yes</item>
                    <item>No</item>
                </items>
            </property>
            <property>
                <name>Serial Agent Device ID</name>
                <type>RANGED_INTEGER</type>
                <readonly>false</readonly>
                <default>1</default>
                <minimum>0</minimum>
                <maximum>65535</maximum>
            </property>
            <property>
                <name>Dump Serial Data</name>
                <type>LIST</type>
                <readonly>false</readonly>
                <default />
                <items>
                    <item>Yes</item>
                    <item>No</item>
                </items>
            </property>
            <property>
                <name>Polling Seconds</name>
                <type>RANGED_INTEGER</type>
                <readonly>false</readonly>
                <default>10</default>
                <minimum>0</minimum>
                <maximum>86400</maximum>
            </property>
            <property>
                <name>Error Message</name>
                <type>STRING</type>
                <readonly>true</readonly>
                <default>SUCCESS</default>
            </property>
            <property>
                <name>Chiller Work Mode Setting</name>
                <type>LIST</type>
                <readonly>false</readonly>
                <default>Cool</default>
                <items>
                    <item>Heat</item>
                    <item>Cool</item>
                </items>
            </property>
            <property>
                <name>Chiller Refrideration Temperature</name>
                <type>RANGED_FLOAT</type>
                <readonly>false</readonly>
                <default>17.0</default>
                <minimum>10</minimum>
                <maximum>25</maximum>
            </property>
            <property>
                <name>Chiller Heat Temperature</name>
                <type>RANGED_FLOAT</type>
                <readonly>false</readonly>
                <default>25.0</default>
                <minimum>25</minimum>
                <maximum>55</maximum>
            </property>
            <property>
                <name>Chiller Running State</name>
                <type>LIST</type>
                <readonly>true</readonly>
                <default>Stop</default>
                <items>
                    <item>Stop</item>
                    <item>Running</item>
                </items>
            </property>
            <property>
                <name>Chiller Antifreezing State</name>
                <type>LIST</type>
                <readonly>true</readonly>
                <default>Stop</default>
                <items>
                    <item>Stop</item>
                    <item>Running</item>
                </items>
            </property>
            <property>
                <name>Chiller Fault State</name>
                <type>LIST</type>
                <readonly>true</readonly>
                <default>No Alarm</default>
                <items>
                    <item>Alarm</item>
                    <item>No Alarm</item>
                </items>
            </property>
            <property>
                <name>Oil pre-Heating State</name>
                <type>LIST</type>
                <readonly>true</readonly>
                <default>No</default>
                <items>
                    <item>Yes</item>
                    <item>No</item>
                </items>
            </property>
            <property>
                <name>AC Water Pump State</name>
                <type>LIST</type>
                <readonly>true</readonly>
                <default>OFF</default>
                <items>
                    <item>On</item>
                    <item>OFF</item>
                </items>
            </property>
            <property>
                <name>Auxiliary Heating State</name>
                <type>LIST</type>
                <readonly>true</readonly>
                <default>OFF</default>
                <items>
                    <item>On</item>
                    <item>OFF</item>
                </items>
            </property>
            <property>
                <name>System Type</name>
                <type>LIST</type>
                <readonly>true</readonly>
                <default>Only Cool</default>
                <items>
                    <item>Heat</item>
                    <item>Only Cool</item>
                </items>
            </property>
            <property>
                <name>Communicate With Wired Controller</name>
                <type>LIST</type>
                <readonly>true</readonly>
                <default>OK</default>
                <items>
                    <item>OK</item>
                    <item>ERROR</item>
                </items>
            </property>
            <property>
                <name>Chiller Working Mode</name>
                <type>LIST</type>
                <readonly>true</readonly>
                <default>Cool</default>
                <items>
                    <item>Heat</item>
                    <item>Cool</item>
                </items>
            </property>
            <property>
                <name>Select A Module</name>
                <type>RANGED_INTEGER</type>
                <readonly>false</readonly>
                <default>1</default>
                <minimum>1</minimum>
                <maximum>8</maximum>
            </property>
            <property>
                <name>Module IO Board Output</name>
                <type>LIST</type>
                <readonly>true</readonly>
                <default>No Alarm</default>
                <items>
                    <item>Alarm</item>
                    <item>No Alarm</item>
                </items>
            </property>
            <property>
                <name>Module Compressor State</name>
                <type>STRING</type>
                <readonly>true</readonly>
                <default>all stop</default>
            </property>
            <property>
                <name>Module Defrost Running</name>
                <type>STRING</type>
                <readonly>true</readonly>
                <default>All stop</default>
            </property>
            <property>
                <name>Module Compressor Current</name>
                <type>STRING</type>
                <readonly>true</readonly>
                <default />
            </property>
            <property>
                <name>Module Online</name>
                <type>LIST</type>
                <readonly>true</readonly>
                <default>OFF</default>
                <items>
                    <item>On</item>
                    <item>OFF</item>
                </items>
            </property>
            <property>
                <name>Module Fault Code</name>
                <type>STRING</type>
                <readonly>true</readonly>
                <default>No Fault</default>
            </property>
            <property>
                <name>Module Env Temperature</name>
                <type>RANGED_FLOAT</type>
                <readonly>true</readonly>
                <default>0.0</default>
                <minimum>-50</minimum>
                <maximum>100</maximum>
            </property>
            <property>
                <name>Module Inlet Temperature</name>
                <type>RANGED_FLOAT</type>
                <readonly>true</readonly>
                <default>0.0</default>
                <minimum>-50</minimum>
                <maximum>100</maximum>
            </property>
            <property>
                <name>Module Outlet Temperature</name>
                <type>RANGED_FLOAT</type>
                <readonly>true</readonly>
                <default>0.0</default>
                <minimum>-50</minimum>
                <maximum>100</maximum>
            </property>
            <property>
                <name>Module Fin Temperature</name>
                <type>STRING</type>
                <readonly>true</readonly>
                <default>NA</default>
            </property>
            <property>
                <name>Module Input Voltage</name>
                <type>RANGED_FLOAT</type>
                <readonly>true</readonly>
                <default>0</default>
                <minimum>0</minimum>
                <maximum>1000</maximum>
            </property>
            <property>
                <name>Module Exhaust Temperature</name>
                <type>STRING</type>
                <readonly>true</readonly>
                <default>NA</default>
            </property>
        </properties>
    </config>
    <events>
        <event>
            <id>1</id>
            <name>Chiller Antifreezing Started</name>
            <description>Chiller Antifreezing Started from NAME</description>
        </event>
        <event>
            <id>2</id>
            <name>Chiller Antifreezing Stopped</name>
            <description>Chiller Antifreezing Stopped from NAME</description>
        </event>
        <event>
            <id>3</id>
            <name>Chiller Has Fault</name>
            <description>Chiller Has Fault from NAME</description>
        </event>
        <event>
            <id>4</id>
            <name>Chiller Fault clear</name>
            <description>Chiller Fault clear from NAME</description>
        </event>
        <event>
            <id>5</id>
            <name>Chiller Started</name>
            <description>Chiller Started from NAME</description>
        </event>
        <event>
            <id>6</id>
            <name>Chiller Stopped</name>
            <description>Chiller Stopped from NAME</description>
        </event>
        <event>
            <id>7</id>
            <name>Module 1 Compressor State Changed</name>
            <description>Module 1 Compressor State Changed from NAME</description>
        </event>
        <event>
            <id>8</id>
            <name>Module 1 Defrost Running Units</name>
            <description>Module 1 Defrost Running Units from NAME</description>
        </event>
        <event>
            <id>9</id>
            <name>Module 1 Malfunction</name>
            <description>Module 1 Malfunction from NAME</description>
        </event>
        <event>
            <id>10</id>
            <name>Module 1 Operational</name>
            <description>Module 1 Operational from NAME</description>
        </event>
        <event>
            <id>11</id>
            <name>Module 1 IO Board Alarm</name>
            <description>Module 1 IO Board Alarm from NAME</description>
        </event>
        <event>
            <id>12</id>
            <name>Module 1 IO Board Clear</name>
            <description>Module 1 IO Board Clear from NAME</description>
        </event>
        <event>
            <id>13</id>
            <name>Module 1 Online</name>
            <description>Module 1 Online from NAME</description>
        </event>
        <event>
            <id>14</id>
            <name>Module 1 Offline</name>
            <description>Module 1 Offline from NAME</description>
        </event>
        <event>
            <id>15</id>
            <name>Module 2 Compressor State Changed</name>
            <description>Module 2 Compressor State Changed from NAME</description>
        </event>
        <event>
            <id>16</id>
            <name>Module 2 Defrost Running Units</name>
            <description>Module 2 Defrost Running Units from NAME</description>
        </event>
        <event>
            <id>17</id>
            <name>Module 2 Malfunction</name>
            <description>Module 2 Malfunction from NAME</description>
        </event>
        <event>
            <id>18</id>
            <name>Module 2 Operational</name>
            <description>Module 2 Operational from NAME</description>
        </event>
        <event>
            <id>19</id>
            <name>Module 2 IO Board Alarm</name>
            <description>Module 2 IO Board Alarm from NAME</description>
        </event>
        <event>
            <id>20</id>
            <name>Module 2 IO Board Clear</name>
            <description>Module 2 IO Board Clear from NAME</description>
        </event>
        <event>
            <id>21</id>
            <name>Module 2 Online</name>
            <description>Module 2 Online from NAME</description>
        </event>
        <event>
            <id>22</id>
            <name>Module 2 Offline</name>
            <description>Module 2 Offline from NAME</description>
        </event>
        <event>
            <id>23</id>
            <name>Module 3 Compressor State Changed</name>
            <description>Module 3 Compressor State Changed from NAME</description>
        </event>
        <event>
            <id>24</id>
            <name>Module 3 Defrost Running Units</name>
            <description>Module 3 Defrost Running Units from NAME</description>
        </event>
        <event>
            <id>25</id>
            <name>Module 3 Malfunction</name>
            <description>Module 3 Malfunction from NAME</description>
        </event>
        <event>
            <id>26</id>
            <name>Module 3 Operational</name>
            <description>Module 3 Operational from NAME</description>
        </event>
        <event>
            <id>27</id>
            <name>Module 3 IO Board Alarm</name>
            <description>Module 3 IO Board Alarm from NAME</description>
        </event>
        <event>
            <id>28</id>
            <name>Module 3 IO Board Clear</name>
            <description>Module 3 IO Board Clear from NAME</description>
        </event>
        <event>
            <id>29</id>
            <name>Module 3 Online</name>
            <description>Module 3 Online from NAME</description>
        </event>
        <event>
            <id>30</id>
            <name>Module 3 Offline</name>
            <description>Module 3 Offline from NAME</description>
        </event>
        <event>
            <id>31</id>
            <name>Module 4 Compressor State Changed</name>
            <description>Module 4 Compressor State Changed from NAME</description>
        </event>
        <event>
            <id>32</id>
            <name>Module 4 Defrost Running Units</name>
            <description>Module 4 Defrost Running Units from NAME</description>
        </event>
        <event>
            <id>33</id>
            <name>Module 4 Malfunction</name>
            <description>Module 4 Malfunction from NAME</description>
        </event>
        <event>
            <id>34</id>
            <name>Module 4 Operational</name>
            <description>Module 4 Operational from NAME</description>
        </event>
        <event>
            <id>35</id>
            <name>Module 4 IO Board Alarm</name>
            <description>Module 4 IO Board Alarm from NAME</description>
        </event>
        <event>
            <id>36</id>
            <name>Module 4 IO Board Clear</name>
            <description>Module 4 IO Board Clear from NAME</description>
        </event>
        <event>
            <id>37</id>
            <name>Module 4 Online</name>
            <description>Module 4 Online from NAME</description>
        </event>
        <event>
            <id>38</id>
            <name>Module 4 Offline</name>
            <description>Module 4 Offline from NAME</description>
        </event>
        <event>
            <id>39</id>
            <name>Module 5 Compressor State Changed</name>
            <description>Module 5 Compressor State Changed from NAME</description>
        </event>
        <event>
            <id>40</id>
            <name>Module 5 Defrost Running Units</name>
            <description>Module 5 Defrost Running Units from NAME</description>
        </event>
        <event>
            <id>41</id>
            <name>Module 5 Malfunction</name>
            <description>Module 5 Malfunction from NAME</description>
        </event>
        <event>
            <id>42</id>
            <name>Module 5 Operational</name>
            <description>Module 5 Operational from NAME</description>
        </event>
        <event>
            <id>43</id>
            <name>Module 5 IO Board Alarm</name>
            <description>Module 5 IO Board Alarm from NAME</description>
        </event>
        <event>
            <id>44</id>
            <name>Module 5 IO Board Clear</name>
            <description>Module 5 IO Board Clear from NAME</description>
        </event>
        <event>
            <id>45</id>
            <name>Module 5 Online</name>
            <description>Module 5 Online from NAME</description>
        </event>
        <event>
            <id>46</id>
            <name>Module 5 Offline</name>
            <description>Module 5 Offline from NAME</description>
        </event>
        <event>
            <id>47</id>
            <name>Module 6 Compressor State Changed</name>
            <description>Module 6 Compressor State Changed from NAME</description>
        </event>
        <event>
            <id>48</id>
            <name>Module 6 Defrost Running Units</name>
            <description>Module 6 Defrost Running Units from NAME</description>
        </event>
        <event>
            <id>49</id>
            <name>Module 6 Malfunction</name>
            <description>Module 6 Malfunction from NAME</description>
        </event>
        <event>
            <id>50</id>
            <name>Module 6 Operational</name>
            <description>Module 6 Operational from NAME</description>
        </event>
        <event>
            <id>51</id>
            <name>Module 6 IO Board Alarm</name>
            <description>Module 6 IO Board Alarm from NAME</description>
        </event>
        <event>
            <id>52</id>
            <name>Module 6 IO Board Clear</name>
            <description>Module 6 IO Board Clear from NAME</description>
        </event>
        <event>
            <id>53</id>
            <name>Module 6 Online</name>
            <description>Module 6 Online from NAME</description>
        </event>
        <event>
            <id>54</id>
            <name>Module 6 Offline</name>
            <description>Module 6 Offline from NAME</description>
        </event>
        <event>
            <id>55</id>
            <name>Module 7 Compressor State Changed</name>
            <description>Module 7 Compressor State Changed from NAME</description>
        </event>
        <event>
            <id>56</id>
            <name>Module 7 Defrost Running Units</name>
            <description>Module 7 Defrost Running Units from NAME</description>
        </event>
        <event>
            <id>57</id>
            <name>Module 7 Malfunction</name>
            <description>Module 7 Malfunction from NAME</description>
        </event>
        <event>
            <id>58</id>
            <name>Module 7 Operational</name>
            <description>Module 7 Operational from NAME</description>
        </event>
        <event>
            <id>59</id>
            <name>Module 7 IO Board Alarm</name>
            <description>Module 7 IO Board Alarm from NAME</description>
        </event>
        <event>
            <id>60</id>
            <name>Module 7 IO Board Clear</name>
            <description>Module 7 IO Board Clear from NAME</description>
        </event>
        <event>
            <id>61</id>
            <name>Module 7 Online</name>
            <description>Module 7 Online from NAME</description>
        </event>
        <event>
            <id>62</id>
            <name>Module 7 Offline</name>
            <description>Module 7 Offline from NAME</description>
        </event>
        <event>
            <id>63</id>
            <name>Module 8 Compressor State Changed</name>
            <description>Module 8 Compressor State Changed from NAME</description>
        </event>
        <event>
            <id>64</id>
            <name>Module 8 Defrost Running Units</name>
            <description>Module 8 Defrost Running Units from NAME</description>
        </event>
        <event>
            <id>65</id>
            <name>Module 8 Malfunction</name>
            <description>Module 8 Malfunction from NAME</description>
        </event>
        <event>
            <id>66</id>
            <name>Module 8 Operational</name>
            <description>Module 8 Operational from NAME</description>
        </event>
        <event>
            <id>67</id>
            <name>Module 8 IO Board Alarm</name>
            <description>Module 8 IO Board Alarm from NAME</description>
        </event>
        <event>
            <id>68</id>
            <name>Module 8 IO Board Clear</name>
            <description>Module 8 IO Board Clear from NAME</description>
        </event>
        <event>
            <id>69</id>
            <name>Module 8 Online</name>
            <description>Module 8 Online from NAME</description>
        </event>
        <event>
            <id>70</id>
            <name>Module 8 Offline</name>
            <description>Module 8 Offline from NAME</description>
        </event>
    </events>
</devicedata>