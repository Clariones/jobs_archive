<devicedata>
    <copyright>Copyright 2014 Control4 Corporation.  All rights reserved.</copyright>
    <creator>SkyNet</creator>
    <manufacturer>SkyNet</manufacturer>
    <name>UDP Display Agent</name>
    <model>UDPAgent</model>
    <created>01/13/2016 11:05 AM</created>
    <modified>01/23/2016 5:02 PM</modified>
    <version>2</version>
    <small>devices_sm\relaysingle_garagedoor_close.gif</small>
    <large>devices_lg\contactsingle_garagedoorsensor_close.gif</large>
    <control>lua_gen</control>
    <controlmethod>ip</controlmethod>
    <driver>DriverWorks</driver>
    <search_type>SkyNet</search_type>
    <templatedescription>Base Template, used in all templates.</templatedescription>
    <combo>True</combo>
    <OnlineCategory>others</OnlineCategory>
    <proxies qty="1">
        <proxy>DisplayAgent_UDP_SkyNet_Proxy</proxy>
    </proxies>
    <connections>
        <connection>
            <id>1</id>
            <facing>1</facing>
            <connectionname>Data Proxy</connectionname>
            <type>1</type>
            <consumer>False</consumer>
            <audiosource>False</audiosource>
            <videosource>False</videosource>
            <linelevel>True</linelevel>
            <classes>
                <class>
                    <classname>DATA_PROXY</classname>
                    <autobind>True</autobind>
                </class>
            </classes>
        </connection>
        <connection>
            <id>6001</id>
            <facing>1</facing>
            <connectionname>UDP</connectionname>
            <type>4</type>
            <consumer>True</consumer>
            <audiosource>False</audiosource>
            <videosource>False</videosource>
            <linelevel>False</linelevel>
            <classes>
                <class>
                    <classname>UDP</classname>
                    <ports>
                        <port>
                            <number>16088</number>
                            <auto_connect>True</auto_connect>
                            <monitor_connection>True</monitor_connection>
                        </port>
                    </ports>
                </class>
            </classes>
        </connection>
    </connections>
    <config>
        <power_management_method>AlwaysOn</power_management_method>
        <power_command_delay>0</power_command_delay>
        <power_delay>0</power_delay>
        <power_command_needed>False</power_command_needed>
        <documentation>
        </documentation>
        <script><![CDATA[
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-- Driver Declarations
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
--[[
  Command Handler Tables
--]]
EX_CMD = {}
PRX_CMD = {}
NOTIFY = {}
DEV_MSG = {}
LUA_ACTION = {}

--[[
Tables of functions
The following tables are function containers that are called within the following functions:  

  OnDriverInit()
    - first calls all functions contained within ON_DRIVER_EARLY_INIT table
    - then calls all functions contained within ON_DRIVER_INIT table
  OnDriverLateInit()
    - calls all functions contained within ON_DRIVER_LATEINIT table
  OnDriverUpdate()
    - calls all functions contained within ON_DRIVER_UPDATE table
  OnDriverDestroyed()
    - calls all functions contained within ON_DRIVER_DESTROYED table
  OnPropertyChanged()
    - calls all functions contained within ON_PROPERTY_CHANGED table
--]]
ON_DRIVER_INIT = {}
ON_DRIVER_EARLY_INIT = {}
ON_DRIVER_LATEINIT = {}
ON_DRIVER_UPDATE = {}
ON_DRIVER_DESTROYED = {}
ON_PROPERTY_CHANGED = {}

-- Constants
DEFAULT_PROXY_BINDINGID = 5001
    
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-- Common Driver Code
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
--[[
  OnPropertyChanged
    Function called by Director when a property changes value.
  Parameters
    sProperty
      Name of property that has changed.
  Remarks
    The value of the property that has changed can be found with: Properties[sName]. Note
    that OnPropertyChanged is not called when the Property has been changed by the driver
    calling the UpdateProperty command, only when the Property is changed by the user from
    the Properties Page. This function is called by Director when a property changes value.
--]]
function OnPropertyChanged(sProperty)
  Dbg:Trace("OnPropertyChanged(" .. sProperty .. ") changed to: " .. Properties[sProperty])

  local propertyValue = Properties[sProperty]
  
  -- Remove any spaces (trim the property)
  local trimmedProperty = string.gsub(sProperty, " ", "")

  -- if function exists then execute (non-stripped)
  if (ON_PROPERTY_CHANGED[sProperty] ~= nil and type(ON_PROPERTY_CHANGED[sProperty]) == "function") then
    ON_PROPERTY_CHANGED[sProperty](propertyValue)
    return
  -- elseif trimmed function exists then execute
  elseif (ON_PROPERTY_CHANGED[trimmedProperty] ~= nil and type(ON_PROPERTY_CHANGED[trimmedProperty]) == "function") then
    ON_PROPERTY_CHANGED[trimmedProperty](propertyValue)
    return
  end
end

function ON_PROPERTY_CHANGED.DebugMode(propertyValue)
  if (gDebugTimer ~= nil ) then  gDebugTimer:KillTimer() end
  Dbg:OutputPrint(propertyValue:find("Print") ~= nil)
  Dbg:OutputC4Log(propertyValue:find("Log") ~= nil)
  if (propertyValue == "Off") then return end
  if (gDebugTimer ~= nil ) then gDebugTimer:StartTimer() end
end

function ON_PROPERTY_CHANGED.DebugLevel(propertyValue)
  Dbg:SetLogLevel(tonumber(string.sub(propertyValue, 1, 1)))
end

---------------------------------------------------------------------
-- ExecuteCommand Code
---------------------------------------------------------------------
--[[
  ExecuteCommand
    Function called by Director when a command is received for this DriverWorks driver.
    This includes commands created in Composer programming.
  Parameters
    sCommand
      Command to be sent
    tParams
      Lua table of parameters for the sent command
--]]
function ExecuteCommand(sCommand, tParams)
  Dbg:Trace("ExecuteCommand(" .. sCommand .. ")")
  Dbg:Info(tParams)

  -- Remove any spaces (trim the command)
  local trimmedCommand = string.gsub(sCommand, " ", "")

  -- if function exists then execute (non-stripped)
  if (EX_CMD[sCommand] ~= nil and type(EX_CMD[sCommand]) == "function") then
    EX_CMD[sCommand](tParams)
  -- elseif trimmed function exists then execute
  elseif (EX_CMD[trimmedCommand] ~= nil and type(EX_CMD[trimmedCommand]) == "function") then
    EX_CMD[trimmedCommand](tParams)
  -- handle the command
  elseif (EX_CMD[sCommand] ~= nil) then
    QueueCommand(EX_CMD[sCommand])
  else
    Dbg:Alert("ExecuteCommand: Unhandled command = " .. sCommand)
  end
end

--[[
  Define any functions of commands (EX_CMD.<command>) received from ExecuteCommand that need to be handled by the driver.
--]]

--[[
  EX_CMD.LUA_ACTION
    Function called for any actions executed by the user from the Actions Tab in Composer.
--]]
function EX_CMD.LUA_ACTION(tParams)
  if tParams ~= nil then
    for cmd,cmdv in pairs(tParams) do
      if cmd == "ACTION" then
        if (LUA_ACTION[cmdv] ~= nil) then
          LUA_ACTION[cmdv]()
        else
          Dbg:Alert("Undefined Action")
          Dbg:Alert("Key: " .. cmd .. " Value: " .. cmdv)
        end
      else
        Dbg:Alert("Undefined Command")
        Dbg:Alert("Key: " .. cmd .. " Value: " .. cmdv)
      end
    end
  end
end

--[[
  LUA_ACTION.DisplayGlobals
    Implementation of Action "Display Globals". Executed when selecting the "Display Globals" action within Composer.
    Provided as an example for actions.
--]]
function LUA_ACTION.DisplayGlobals()
  print ("Global Variables")
  print ("----------------------------")

  for k,v in pairs(_G) do -- globals`
    if not (type(v) == "function") then
      --print(k .. ":  " .. tostring(v))
      if (string.find(k, "^g%L")  == 1) then
        print(k .. ":  " .. tostring(v))
        if (type(v) == "table") then
          PrintTable(v, "   ")
        end
      end
    end
  end

  print ("")
end

function PrintTable(tValue, sIndent)
  sIndent = sIndent or "   "
  for k,v in pairs(tValue) do
    print(sIndent .. tostring(k) .. ":  " .. tostring(v))
    if (type(v) == "table") then
      PrintTable(v, sIndent .. "   ")
    end
  end
end

---------------------------------------------------------------------
-- ReceivedFromProxy Code
---------------------------------------------------------------------
--[[
  ReceivedFromProxy(idBinding, sCommand, tParams)
    Function called by Director when a proxy bound to the specified binding sends a
    BindMessage to the DriverWorks driver.

  Parameters
    idBinding
      Binding ID of the proxy that sent a BindMessage to the DriverWorks driver.
    sCommand
      Command that was sent
    tParams
      Lua table of received command parameters
--]]
function ReceivedFromProxy(idBinding, sCommand, tParams)
  if (sCommand ~= nil) then
    if(tParams == nil)    -- initial table variable if nil
      then tParams = {}
    end
    Dbg:Trace("ReceivedFromProxy(): " .. sCommand .. " on binding " .. idBinding .. "; Call Function " .. sCommand .. "()")
    Dbg:Info(tParams)

    if (PRX_CMD[sCommand]) ~= nil then
      PRX_CMD[sCommand](idBinding, tParams)
    else
      Dbg:Alert("ReceivedFromProxy: Unhandled command = " .. sCommand)
    end
  end
end

---------------------------------------------------------------------
-- Notification Code
---------------------------------------------------------------------
-- notify with parameters
function SendNotify(notifyText, Parms, bindingID)
  C4:SendToProxy(bindingID, notifyText, Parms, "NOTIFY")
end

-- A notify with no parameters
function SendSimpleNotify(notifyText, ...)
  bindingID = select(1, ...) or DEFAULT_PROXY_BINDINGID
  C4:SendToProxy(bindingID, notifyText, {}, "NOTIFY")
end

---------------------------------------------------------------------
-- Initialization/Destructor Code
---------------------------------------------------------------------
--[[
  OnDriverInit
    Invoked by director when a driver is loaded. This API is provided for the driver developer to contain all of the driver
    objects that will require initialization.
--]]
function OnDriverInit()
  C4:ErrorLog("INIT_CODE: OnDriverInit()")
  -- Call all ON_DRIVER_EARLY_INIT functions.
  for k,v in pairs(ON_DRIVER_EARLY_INIT) do
    if (ON_DRIVER_EARLY_INIT[k] ~= nil and type(ON_DRIVER_EARLY_INIT[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_EARLY_INIT." .. k .. "()")
      ON_DRIVER_EARLY_INIT[k]()
    end
  end

  -- Call all ON_DRIVER_INIT functions
  for k,v in pairs(ON_DRIVER_INIT) do
    if (ON_DRIVER_INIT[k] ~= nil and type(ON_DRIVER_INIT[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_INIT." .. k .. "()")
      ON_DRIVER_INIT[k]()
    end
  end

  -- Fire OnPropertyChanged to set the initial Headers and other Property global sets, they'll change if Property is changed.
  for k,v in pairs(Properties) do
    OnPropertyChanged(k)
  end
end

--[[
  OnDriverUpdate
    Invoked by director when an update to a driver is requested. This request can occur either by adding a new version of a driver
    through the driver search list or right clicking on the driver and selecting "Update Driver" from within ComposerPro.
    Its purpose is to initialize all components of the driver that are reset during a driver update.
--]]
function OnDriverUpdate()
  C4:ErrorLog("INIT_CODE: OnDriverUpdate()")
  
  -- Call all ON_DRIVER_UPDATE functions
  for k,v in pairs(ON_DRIVER_UPDATE) do
    if (ON_DRIVER_UPDATE[k] ~= nil and type(ON_DRIVER_UPDATE[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_UPDATE." .. k .. "()")
      ON_DRIVER_UPDATE[k]()
    end
  end
end

--[[
  OnDriverLateInit
    Invoked by director after all drivers in the project have been loaded. This API is provided
    for the driver developer to contain all of the driver objects that will require initialization
    after all drivers in the project have been loaded.
--]]
function OnDriverLateInit()
  C4:ErrorLog("INIT_CODE: OnDriverLateInit()")
  
  -- Call all ON_DRIVER_LATEINIT functions
  for k,v in pairs(ON_DRIVER_LATEINIT) do
    if (ON_DRIVER_LATEINIT[k] ~= nil and type(ON_DRIVER_LATEINIT[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_LATEINIT." .. k .. "()")
      ON_DRIVER_LATEINIT[k]()
    end
  end
end


--[[
  OnDriverDestroyed
    Function called by Director when a driver is removed. Release things this driver has allocated such as timers.
--]]
function OnDriverDestroyed()
  C4:ErrorLog("INIT_CODE: OnDriverDestroyed()")
  -- Call all ON_DRIVER_DESTROYED functions
  for k,v in pairs(ON_DRIVER_DESTROYED) do
    if (ON_DRIVER_DESTROYED[k] ~= nil and type(ON_DRIVER_DESTROYED[k]) == "function") then
      C4:ErrorLog("INIT_CODE: ON_DRIVER_DESTROYED." .. k .. "()")
      ON_DRIVER_DESTROYED[k]()
    end
  end
end

--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-- Debug Logging Code
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Log = {}

-- Create a Table with Logging functions
function Log:Create()
  
  -- table for logging functions
  local lt = {}
  
  lt._logLevel = 0
  lt._outputPrint = false
  lt._outputC4Log = false
  lt._logName =  "Set Log Name to display"
  
  function lt:SetLogLevel(level)
    self._logLevel = level
  end
  
  function lt:OutputPrint(value)
    self._outputPrint = value
  end
  
  function lt:OutputC4Log(value)
    self._outputC4Log = value
  end
  
  function lt:SetLogName(name)
    self._logName = name
  end

  function lt:Enabled()
    return (self._outputPrint or self._outputC4Log)
  end
  
  function lt:PrintTable(tValue, sIndent)
    if (type(tValue) == "table") then
      if (self._outputPrint) then
        for k,v in pairs(tValue) do
          print(sIndent .. tostring(k) .. ":  " .. tostring(v))
          if (type(v) == "table") then
            self:PrintTable(v, sIndent .. "   ")
          end
        end
      end
  
      if (self._outputC4Log) then
        for k,v in pairs(tValue) do
          C4:ErrorLog(self._logName .. ": " .. sIndent .. tostring(k) .. ":  " .. tostring(v))
          if (type(v) == "table") then
            self:PrintTable(v, sIndent .. "   ")
          end
        end
      end

    else
      if (self._outputPrint) then
        print (sIndent .. tValue)
      end
      
      if (self._outputC4Log) then
        C4:ErrorLog(self._logName .. ": " .. sIndent .. tValue)
      end
    end
  end
    
  function lt:Print(logLevel, sLogText)
    if (self._logLevel >= logLevel) then
      if (type(sLogText) == "table") then
        self:PrintTable(sLogText, "   ")
        return
      end
      
      if (self._outputPrint) then
        print (sLogText)
      end

      if (self._outputC4Log) then
        C4:ErrorLog(self._logName .. ": " .. sLogText)
      end
    end
  end
  
  function lt:Alert(strDebugText)
	if (strDebugText == nil) then return end
    self:Print(0, strDebugText)
  end
  
  function lt:Error(strDebugText)
    if (strDebugText == nil) then return end
    self:Print(1, strDebugText)
  end
  
  function lt:Warn(strDebugText)
  if (strDebugText == nil) then return end
    self:Print(2, strDebugText)
  end
  
  function lt:Info(strDebugText)
  if (strDebugText == nil) then return end
    self:Print(3, strDebugText)
  end
  
  function lt:Trace(strDebugText)
  if (strDebugText == nil) then return end
    self:Print(4, strDebugText)
  end
  
  function lt:Debug(strDebugText)
  if (strDebugText == nil) then return end
    self:Print(5, strDebugText)
  end
  
  return lt
end

function ON_DRIVER_EARLY_INIT.LogLib()
  -- Create and initialize debug logging
  Dbg = Log.Create()
  Dbg:SetLogName("DisplayAgentUDP")
end

function ON_DRIVER_INIT.LogLib()
  -- Create Debug Timer
  gDebugTimer = Timer:Create("Debug", 45, "MINUTES", OnDebugTimerExpired)
end

--[[
  OnDebugTimerExpired
    Debug timer callback function
--]]
function OnDebugTimerExpired()
  Dbg:Warn("Turning Debug Mode Off (timer expired)")
  gDebugTimer:KillTimer()
  C4:UpdateProperty("Debug Mode", "Off")
  OnPropertyChanged("Debug Mode")
end
      
---------------------------------------------------------------------
-- Timer Code
---------------------------------------------------------------------
Timer = {}

-- Create a Table with Timer functions
function Timer:Create(name, interval, units, Callback, repeating, Info)
  -- timers table
  local tt = {}
  
  tt._name = name
  tt._timerID = TimerLibGetNextTimerID()
  tt._interval = interval
  tt._units = units
  tt._repeating = repeating or false
  tt._Callback = Callback
  tt._info = Info or ""
  tt._id = 0

  function tt:StartTimer(...)
    self:KillTimer()
    
    -- optional parameters (interval, units, repeating)
    if ... then
      local interval = select(1, ...)
      local units = select(2, ...)
      local repeating = select(3, ...)
      
      self._interval = interval or self._interval
      self._units = units or self._units
      self._repeating = repeating or self._repeating
    end
    
    if (self._interval > 0) then
      Dbg:Trace("Starting Timer: " .. self._name)
      self._id = C4:AddTimer(self._interval, self._units, self._repeating)
    end
  end

  function tt:KillTimer()
    if (self._id) then
      self._id = C4:KillTimer(self._id)
    end
  end
  
  function tt:TimerStarted()
    return (self._id ~= 0)
  end
      
  function tt:TimerStopped()
    return not self:TimerStarted()
  end
  
  gTimerLibTimers[tt._timerID] = tt
  Dbg:Trace("Created timer " .. tt._name)
  
  return tt
end

function TimerLibGetNextTimerID()
  gTimerLibTimerCurID = gTimerLibTimerCurID + 1
  return gTimerLibTimerCurID
end

function ON_DRIVER_EARLY_INIT.TimerLib()
  gTimerLibTimers = {}
  gTimerLibTimerCurID = 0
end

function ON_DRIVER_DESTROYED.TimerLib()
  -- Kill open timers
  for k,v in pairs(gTimerLibTimers) do
    v:KillTimer()
  end
end

--[[
  OnTimerExpired
    Function called by Director when the specified Control4 timer expires.
  Parameters
    idTimer
      Timer ID of expired timer.
--]]
function OnTimerExpired(idTimer)
  for k,v in pairs(gTimerLibTimers) do
    if (idTimer == v._id) then
      if (v._Callback) then
        v._Callback(v._info)
      end
    end
  end
end

ProtocolHandler = {
  connected = false,
  ipAddress = nil,
  port = nil,
  idBinding = 6001,
}
function ProtocolHandler:SendMessage(msg)
  if (self.ipAddress == nil or self.port == nil) then
    local msg = "Server IP Address or Server port not set. Cannot send any message"
    print(msg)
    Dbg.Error(msg)
    return
  end
 
  local strMsg = self:MsgToString(msg)
  if (not self.connected) then
    --C4:NetConnect(self.idBinding, self.port, "UDP") --TODO
    C4:CreateNetworkConnection(6001, self.ipAddress, "UDP")
    C4:NetConnect(self.idBinding, self.port, "UDP")
    self.connected = true
  end

  Dbg:Debug("Send: " .. strMsg)
  C4:SendToNetwork(self.idBinding, self.port, strMsg)
end

function ProtocolHandler:MsgToString(msg)
  local rstStr = self:EscapeComma(msg.commandCode)
  if (msg.subCommands ~= nil) then
    local subCmds = msg.subCommands
    for i=1,#subCmds do
      rstStr=rstStr..","..self:EscapeComma(subCmds[i])
    end
  end
  if (msg.params ~= nil) then
    for name,value in pairs(msg.params) do
      rstStr=rstStr..","..self:EscapeComma(name).."="..self:EscapeComma(value)
    end
  end
  return rstStr
end

function ProtocolHandler:StringToMsg(strInput)
  local msg = {}
  local array = self:SplitMsg(strInput)
  msg.commandCode = ProtocolHandler:UnEscapeComma(array[1])
  msg.params = {}
  for i=2,#array do
    local pos = string.find(array[i],"=",1,true)
    if pos ~= nil then
      local name = string.sub(array[i],1, pos-1)
      local value = string.sub(array[i],pos+1)
      msg.params[ProtocolHandler:UnEscapeComma(name)] = ProtocolHandler:UnEscapeComma(value)
    else
      if (msg.subCommands == nil) then msg.subCommands = {} end
      local strCmd = ProtocolHandler:UnEscapeComma(array[i])
      table.insert(msg.subCommands,strCmd)
    end
  end
  return msg
end
function ProtocolHandler:SplitMsg(strInput)
  local array = {}
  local pos = 1
  repeat
    local nextPos = string.find(strInput,",",pos,true)
    if (nextPos ~= nil) then
      table.insert(array,string.sub(strInput,pos, nextPos-1))
      pos = nextPos+1
    else
      table.insert(array,string.sub(strInput,pos))
    end
  until(nextPos==nil)
  return array
end

function ProtocolHandler:EscapeComma(strIn)
  if type(strIn)=="boolean" then
    return tostring(strIn)
  end
  return string.gsub(tostring(strIn or "nil"),",","&x2C;")
end
function ProtocolHandler:UnEscapeComma(strIn)
  return string.gsub(strIn,"%&x2C;", ",")
end
      
DeviceInfos = {
  ["SmartSwitchScene"] = {
    profile="SmartSwitchScene",
    variables={
      [1001] = {varName="Dimmer", varType="number"},
      [1002] = {varName="Relay1", varType="string"},
      [1003] = {varName="Relay2", varType="string"},
      [1004] = {varName="WorkMode", varType="string"},
    },
  },
  ["SmartSwitchBlind"] = {
    profile="SmartSwitchBlind",
    variables={
      [1001] = {varName="Dimmer", varType="number"},
      [1002] = {varName="Relay1", varType="string"},
      [1003] = {varName="Relay2", varType="string"},
      [1004] = {varName="WorkMode", varType="string"},
    },
  },
  ["SmartSwitchDimmer"] = {
    profile="SmartSwitchDimmer",
    variables={
      [1001] = {varName="Dimmer", varType="number"},
      [1002] = {varName="Relay1", varType="string"},
      [1003] = {varName="Relay2", varType="string"},
      [1004] = {varName="WorkMode", varType="string"},
    },
  },
  ["SmartSwitchLight"] = {
    profile="SmartSwitchLight",
    variables={
      [1001] = {varName="Dimmer", varType="number"},
      [1002] = {varName="Relay1", varType="string"},
      [1003] = {varName="Relay2", varType="string"},
      [1004] = {varName="WorkMode", varType="string"},
    },
  },
  ["MitsubishiAirCondition"] = {
    profile="MitsubishiAirCondition",
    variables={
      [1001] = {varName="AirExchangeState", varType="string"},
	  [1002] = {varName="CompressorState", varType="string"},
	  [1003] = {varName="FaultCode", varType="number"},
	  [1004] = {varName="FilterState", varType="string"},
	  [1005] = {varName="RemoterLock", varType="string"},
	  [1006] = {varName="RoomTemperature", varType="number"},
	  [1007] = {varName="RunningState", varType="string"},
	  [1008] = {varName="SettingMode", varType="string"},
	  [1009] = {varName="SettingTemperature", varType="number"},
	  [1010] = {varName="WindSpeed", varType="string"},
	  [1011] = {varName="WindSwing", varType="string"},
	  [1012] = {varName="WorkingMode", varType="string"},
    },
  },
  ["AirCooledChiller"] = {
    profile="SmartSwitchLight",
    variables={
      [1001] = {varName="AC Water Pump State", varType="string"},
      [1002] = {varName="Auxiliary Heating State", varType="string"},
      [1003] = {varName="Chiller Antifreezing State", varType="string"},
      [1004] = {varName="Chiller Fault State", varType="string"},
      [1005] = {varName="Chiller Heat Temperature", varType="number"},
      [1006] = {varName="Chiller Refrideration Temperature", varType="number"},
      [1007] = {varName="Chiller Running State", varType="string"},
      [1008] = {varName="Chiller Work Mode Setting", varType="string"},
      [1009] = {varName="Chiller Working Mode", varType="string"},
      [1010] = {varName="Communicate With Wired Controller", varType="string"},
      [1011] = {varName="Module 1 Compressor Current", varType="string"},
      [1012] = {varName="Module 1 Compressor State", varType="string"},
      [1013] = {varName="Module 1 Defrost Running", varType="string"},
      [1014] = {varName="Module 1 Environment Temperature", varType="number"},
      [1015] = {varName="Module 1 Exhause Air Temperature", varType="string"},
      [1016] = {varName="Module 1 Fault Code", varType="string"},
      [1017] = {varName="Module 1 Fin Temperature", varType="string"},
      [1018] = {varName="Module 1 IO Board Output", varType="string"},
      [1019] = {varName="Module 1 Inlet Water Temperature", varType="number"},
      [1020] = {varName="Module 1 Input Voltage", varType="number"},
      [1021] = {varName="Module 1 Online", varType="string"},
      [1022] = {varName="Module 1 Outlet Water Temperature", varType="number"},
      [1023] = {varName="Module 2 Compressor Current", varType="string"},
      [1024] = {varName="Module 2 Compressor State", varType="string"},
      [1025] = {varName="Module 2 Defrost Running", varType="string"},
      [1026] = {varName="Module 2 Environment Temperature", varType="number"},
      [1027] = {varName="Module 2 Exhause Air Temperature", varType="string"},
      [1028] = {varName="Module 2 Fault Code", varType="string"},
      [1029] = {varName="Module 2 Fin Temperature", varType="string"},
      [1030] = {varName="Module 2 IO Board Output", varType="string"},
      [1031] = {varName="Module 2 Inlet Water Temperature", varType="number"},
      [1032] = {varName="Module 2 Input Voltage", varType="number"},
      [1033] = {varName="Module 2 Online", varType="string"},
      [1034] = {varName="Module 2 Outlet Water Temperature", varType="number"},
      [1035] = {varName="Module 3 Compressor Current", varType="string"},
      [1036] = {varName="Module 3 Compressor State", varType="string"},
      [1037] = {varName="Module 3 Defrost Running", varType="string"},
      [1038] = {varName="Module 3 Environment Temperature", varType="number"},
      [1039] = {varName="Module 3 Exhause Air Temperature", varType="string"},
      [1040] = {varName="Module 3 Fault Code", varType="string"},
      [1041] = {varName="Module 3 Fin Temperature", varType="string"},
      [1042] = {varName="Module 3 IO Board Output", varType="string"},
      [1043] = {varName="Module 3 Inlet Water Temperature", varType="number"},
      [1044] = {varName="Module 3 Input Voltage", varType="number"},
      [1045] = {varName="Module 3 Online", varType="string"},
      [1046] = {varName="Module 3 Outlet Water Temperature", varType="number"},
      [1047] = {varName="Module 4 Compressor Current", varType="string"},
      [1048] = {varName="Module 4 Compressor State", varType="string"},
      [1049] = {varName="Module 4 Defrost Running", varType="string"},
      [1050] = {varName="Module 4 Environment Temperature", varType="number"},
      [1051] = {varName="Module 4 Exhause Air Temperature", varType="string"},
      [1052] = {varName="Module 4 Fault Code", varType="string"},
      [1053] = {varName="Module 4 Fin Temperature", varType="string"},
      [1054] = {varName="Module 4 IO Board Output", varType="string"},
      [1055] = {varName="Module 4 Inlet Water Temperature", varType="number"},
      [1056] = {varName="Module 4 Input Voltage", varType="number"},
      [1057] = {varName="Module 4 Online", varType="string"},
      [1058] = {varName="Module 4 Outlet Water Temperature", varType="number"},
      [1059] = {varName="Module 5 Compressor Current", varType="string"},
      [1060] = {varName="Module 5 Compressor State", varType="string"},
      [1061] = {varName="Module 5 Defrost Running", varType="string"},
      [1062] = {varName="Module 5 Environment Temperature", varType="number"},
      [1063] = {varName="Module 5 Exhause Air Temperature", varType="string"},
      [1064] = {varName="Module 5 Fault Code", varType="string"},
      [1065] = {varName="Module 5 Fin Temperature", varType="string"},
      [1066] = {varName="Module 5 IO Board Output", varType="string"},
      [1067] = {varName="Module 5 Inlet Water Temperature", varType="number"},
      [1068] = {varName="Module 5 Input Voltage", varType="number"},
      [1069] = {varName="Module 5 Online", varType="string"},
      [1070] = {varName="Module 5 Outlet Water Temperature", varType="number"},
      [1071] = {varName="Module 6 Compressor Current", varType="string"},
      [1072] = {varName="Module 6 Compressor State", varType="string"},
      [1073] = {varName="Module 6 Defrost Running", varType="string"},
      [1074] = {varName="Module 6 Environment Temperature", varType="number"},
      [1075] = {varName="Module 6 Exhause Air Temperature", varType="string"},
      [1076] = {varName="Module 6 Fault Code", varType="string"},
      [1077] = {varName="Module 6 Fin Temperature", varType="string"},
      [1078] = {varName="Module 6 IO Board Output", varType="string"},
      [1079] = {varName="Module 6 Inlet Water Temperature", varType="number"},
      [1080] = {varName="Module 6 Input Voltage", varType="number"},
      [1081] = {varName="Module 6 Online", varType="string"},
      [1082] = {varName="Module 6 Outlet Water Temperature", varType="number"},
      [1083] = {varName="Module 7 Compressor Current", varType="string"},
      [1084] = {varName="Module 7 Compressor State", varType="string"},
      [1085] = {varName="Module 7 Defrost Running", varType="string"},
      [1086] = {varName="Module 7 Environment Temperature", varType="number"},
      [1087] = {varName="Module 7 Exhause Air Temperature", varType="string"},
      [1088] = {varName="Module 7 Fault Code", varType="string"},
      [1089] = {varName="Module 7 Fin Temperature", varType="string"},
      [1090] = {varName="Module 7 IO Board Output", varType="string"},
      [1091] = {varName="Module 7 Inlet Water Temperature", varType="number"},
      [1092] = {varName="Module 7 Input Voltage", varType="number"},
      [1093] = {varName="Module 7 Online", varType="string"},
      [1094] = {varName="Module 7 Outlet Water Temperature", varType="number"},
      [1095] = {varName="Module 8 Compressor Current", varType="string"},
      [1096] = {varName="Module 8 Compressor State", varType="string"},
      [1097] = {varName="Module 8 Defrost Running", varType="string"},
      [1098] = {varName="Module 8 Environment Temperature", varType="number"},
      [1099] = {varName="Module 8 Exhause Air Temperature", varType="string"},
      [1100] = {varName="Module 8 Fault Code", varType="string"},
      [1101] = {varName="Module 8 Fin Temperature", varType="string"},
      [1102] = {varName="Module 8 IO Board Output", varType="string"},
      [1103] = {varName="Module 8 Inlet Water Temperature", varType="number"},
      [1104] = {varName="Module 8 Input Voltage", varType="number"},
      [1105] = {varName="Module 8 Online", varType="string"},
      [1106] = {varName="Module 8 Outlet Water Temperature", varType="number"},
      [1107] = {varName="Oil pre-Heating State", varType="string"},
      [1108] = {varName="System Type", varType="string"},
    },
  },
  ["CO2Sensor"]={
    profile="CO2Sensor",
    variables={
      [1001] = {varName="CO2 Concentration", varType="number"},
      [1002] = {varName="Measuring Range Offset", varType="number"},
      [1003] = {varName="Range Scale Factor", varType="number"},
    },
  },
  ["NHFS45"]={
    profile="NHFS45",
    variables={
      [1001] = {varName="Wind Speed", varType="number"},
    },
  },
  ["NHFX46"]={
    profile="NHFX46",
    variables={
      [1001] = {varName="Wind Direction", varType="number"},
    },
  },
  ["NH122"]={
    profile="NH122",
    variables={
      [1001] = {varName="Humidity", varType="number"},
      [1002] = {varName="Pressure", varType="number"},
      [1003] = {varName="Temperature", varType="number"},
    },
  },
  ["DustTransmitter"]={
    profile="DustTransmitter",
    variables={
      [1001] = {varName="Dust Concentration", varType="number"},
    },
  },
  ["FormaldehydeTransmiter"]={
    profile="FormaldehydeTransmiter",
    variables={
      [1001] = {varName="Concentration", varType="number"},
      [1002] = {varName="Equivalent", varType="number"},
      [1003] = {varName="Unit", varType="string"},
    },
  },
  ["AW1485A"]={
    profile="AW1485A",
    variables={
      [1001] = {varName="Humidity", varType="number"},
      [1002] = {varName="TemperatureCelsius", varType="number"},
      [1003] = {varName="DeviceTypeID", varType="number"},
      [1004] = {varName="Version", varType="number"},
      [1005] = {varName="TemperatureHighAlarm", varType="number"},
      [1006] = {varName="TemperatureHighAlarmEnable", varType="number"},
      [1007] = {varName="TemperatureLowAlarm", varType="number"},
      [1008] = {varName="TemperatureLowAlarmEnable", varType="number"},
      [1009] = {varName="HumidityHighAlarm", varType="number"},
      [1010] = {varName="HumidityHighAlarmEnable", varType="number"},
      [1011] = {varName="HumidityLowAlarm", varType="number"},
      [1012] = {varName="HumidityLowAlarmEnable", varType="number"},
      [1013] = {varName="TemperatureAdjustment", varType="number"},
      [1014] = {varName="HumidityAdjustment", varType="number"},
    },
  },
  ["NHZD10"]={
    profile="NHZD10",
    variables={
      [1001] = {varName="Illumination", varType="number"},
    },
  },
  ["NHZD210"]={
    profile="NHZD210",
    variables={
      [1001] = {varName="Illumination", varType="number"},
    },
  },
  ["NHJYL42"]={
    profile="NHJYL42",
    variables={
      [1001] = {varName="Rainfull", varType="number"},
    },
  },
  ["NHSF48"]={
    profile="NHSF48",
    variables={
      [1001] = {varName="SoilType", varType="string"},
      [1002] = {varName="Temperature", varType="number"},
      [1003] = {varName="VWC", varType="number"},
      [1004] = {varName="VWCRAWAD", varType="number"},
    },
  },
  ["YKCAirCondition"]={
    profile="YKCAirCondition",
    variables={
      [1001] = {varName="CompensationTmpr", varType="number"},
	  [1002] = {varName="KeyPressLock", varType="string"},
	  [1003] = {varName="RoomTemperature", varType="number"},
	  [1004] = {varName="RunningState", varType="string"},
	  [1005] = {varName="SettingTemperature", varType="number"},
	  [1006] = {varName="WindSpeed", varType="string"},
	  [1007] = {varName="WorkingMode", varType="string"},
    },
  },
}

RegisteredDevices = {}
function WatchDeviceVariables(deviceId, deviceProfile)
  local devInfo = DeviceInfos[deviceProfile]
  if (devInfo==nil) then
    Dbg.Error("Cannot handle profile "..deviceProfile .. " for device "..deviceId)
    return
  end
  for varId,varInfo in pairs(devInfo.variables) do
    C4:UnregisterVariableListener(deviceId, varId)
  end
  RegisteredDevices[tonumber(deviceId)] = deviceProfile
  for varId,varInfo in pairs(devInfo.variables) do
    C4:RegisterVariableListener(tonumber(deviceId), tonumber(varId))
    Dbg:Debug("Listening on " .. deviceProfile .. " " .. deviceId .. "." .. varInfo.varName)
  end
end
function updateDeviceVariable(idDevice, idVariable, strValue)
  -- below are 3 checking rules for update-device-variable:
  --  1. must be registered device
  --  2. must be known profile
  --  3. must be known varibale ID
  local dvcProfile = RegisteredDevices[tonumber(idDevice)]
  if (dvcProfile == nil) then print("Cannot found profile", idDevice) return end
  local dvcInfo = DeviceInfos[dvcProfile]
  if (dvcInfo == nil) then print("Cannot found deviceInfo", dvcProfile) return end
  local varInfo = dvcInfo.variables[tonumber(idVariable)]
  if (varInfo == nil) then print("Cannot found varInfo", idVariable) return end
  
  local msg = {
    commandCode = "UpdateVariable",
    params = {
      [varInfo.varName]=strValue,
      ["deviceId"]=idDevice,
    }
  }
  print("Ready to send", idDevice, idVariable, strValue)
  ProtocolHandler:SendMessage(msg)
end

function queryDeviceProfile(deviceId)
  local dvcProfile = RegisteredDevices[deviceId]
  if (dvcProfile == nil) then return end
  local dvcName = C4:GetDeviceDisplayName(deviceId)
  local msg = {
    commandCode = "UpdateDevice",
    params = {
      ["deviceName"]=dvcName,
      ["deviceProfile"]=dvcProfile,
      ["deviceId"]=deviceId,
    }
  }
  ProtocolHandler:SendMessage(msg)
end
function executeUdpCmd(strCmd, strDeviceId, tParams)
  print("execute " .. strCmd .. " on device " .. tonumber(strDeviceId))
  C4:SendToDevice(tonumber(strDeviceId),strCmd,tParams)
end

function ON_DRIVER_LATEINIT:DriverInit()
  local devs = C4:GetBoundConsumerDevices(0, 1)
  for id,name in pairs(devs) do
    C4:SendToDevice(id,"WhoAmI",{})
  end
end


function ClearAll()
  local msg = {
    commandCode = "ResetData",
  }
  ProtocolHandler:SendMessage(msg)
end

function LUA_ACTION.ClearAll()
  ClearAll()
end

function LUA_ACTION.UpdateConnDevices()
  local devs = C4:GetBoundConsumerDevices(0, 1)
  for id,name in pairs(devs) do
    C4:SendToDevice(id,"WhoAmI",{deviceId=C4:GetDeviceID()})
  end
end

function LUA_ACTION.TestConnection()
  local msg = {
  commandCode = "TestConnection",
  params = {
      ["sendDate"]=os.date(),
      ["sendTime"]=os.time(),
      ["deviceId"]=C4:GetDeviceID(),
    }
  }
  ProtocolHandler:SendMessage(msg)
end

function OnConnectionStatusChanged(idBinding, nPort, strStatus)
  Dbg:Info("idBinding, nPort, strStatus="..idBinding..","..nPort..","..strStatus)
  if (strStatus=="OFFLINE") then
    ProtocolHandler.connected = false
  else 
    ProtocolHandler.connected = true 
  end
end

function ReceivedFromNetwork(idBinding, nPort, strData)
  Dbg:Debug("receive ".. strData)
  local msg = ProtocolHandler:StringToMsg(strData)
  if (msg.commandCode == "QueryDevice") then
    queryDeviceProfile(tonumber(msg.params.deviceId))
  elseif (msg.commandCode == "ExecuteCmd") then
    executeUdpCmd(msg.subCommands[1], msg.params["deviceId"], msg.params)
  elseif (msg.commandCode == "TestConnection") then
  print("Test Connection Success")
  end
end

function ON_PROPERTY_CHANGED.ServerIPAddress(propertyValue)
local pattern = "^%d+%.%d+%.%d+%.%d+$"
  if string.match(propertyValue,pattern) == nil then
    C4:UpdateProperty("Server IP Address", "invalid IP Address")
    return
  end
  if (ProtocolHandler.ipAddress ~= nil) then
    ProtocolHandler.connected = false
  end
  ProtocolHandler.ipAddress = propertyValue
  
  if (ProtocolHandler.port ~= nil and ProtocolHandler.connected==false) then
    ClearAll()
  end
end
function ON_PROPERTY_CHANGED.ServerPort(propertyValue)
  if (ProtocolHandler.port ~= nil) then
    C4:NetDisconnect(6001, ProtocolHandler.port)
    ProtocolHandler.connected = false
  end
 
  ProtocolHandler.port = tonumber(propertyValue)
  if (ProtocolHandler.ipAddress ~= nil and ProtocolHandler.connected==false) then
    ClearAll()
  end
end

function EX_CMD.UpdateProfile(tParams)
  if tParams.deviceId == nil then return end
  if tParams.profile == nil then return end
  
  WatchDeviceVariables(tonumber(tParams.deviceId), tParams.profile)
end

function OnWatchedVariableChanged(idDevice, idVariable, strValue)
  print("OnWatchedVariableChanged()", idDevice, idVariable, strValue)
  updateDeviceVariable(idDevice, idVariable, strValue)
end]]></script>
        <actions>
            <action>
                <name>Display Globals</name>
                <command>DisplayGlobals</command>
            </action>
            <action>
                <name>Clear</name>
                <command>ClearAll</command>
            </action>
            <action>
                <name>Test Connection</name>
                <command>TestConnection</command>
            </action>
            <action>
                <name>Refresh Connected Devices</name>
                <command>UpdateConnDevices</command>
            </action>
        </actions>
        <commands>
            <command>
                <name>PostVariable</name>
                <description>Post a variable value to me</description>
                <params>
                    <param>
                        <name>DeviceID</name>
                        <type>RANGED_INTEGER</type>
                        <readonly>False</readonly>
                        <default />
                        <minimum>1</minimum>
                        <maximum>65535</maximum>
                    </param>
                    <param>
                        <name>VariableID</name>
                        <type>RANGED_INTEGER</type>
                        <readonly>False</readonly>
                        <default />
                        <minimum>1001</minimum>
                        <maximum>65535</maximum>
                    </param>
                    <param>
                        <name>Description</name>
                        <type>STRING</type>
                        <readonly>False</readonly>
                        <default>Unknown</default>
                    </param>
                    <param>
                        <name>Unit</name>
                        <type>STRING</type>
                        <readonly>False</readonly>
                        <default>(na)</default>
                    </param>
                </params>
            </command>
            <command>
                <name>ClearAll</name>
                <description>Clear all and restart</description>
            </command>
        </commands>
        <properties>
            <property>
                <name>Debug Level</name>
                <type>LIST</type>
                <readonly>false</readonly>
                <default>2 - Warning</default>
                <items>
                    <item>0 - Alert</item>
                    <item>1 - Error</item>
                    <item>2 - Warning</item>
                    <item>3 - Info</item>
                    <item>4 - Trace</item>
                    <item>5 - Debug</item>
                </items>
            </property>
            <property>
                <name>Debug Mode</name>
                <type>LIST</type>
                <readonly>false</readonly>
                <default>Off</default>
                <items>
                    <item>Off</item>
                    <item>Print</item>
                    <item>Log</item>
                    <item>Print and Log</item>
                </items>
            </property>
            <property>
                <name>Server IP Address</name>
                <type>STRING</type>
                <readonly>false</readonly>
                <default />
            </property>
            <property>
                <name>Server Port</name>
                <type>RANGED_INTEGER</type>
                <readonly>false</readonly>
                <default>2080</default>
                <minimum>1025</minimum>
                <maximum>65534</maximum>
            </property>
        </properties>
    </config>
</devicedata>